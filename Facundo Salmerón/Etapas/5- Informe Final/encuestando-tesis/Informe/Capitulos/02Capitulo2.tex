%---------------------------------------------------------------------
%
%                          Capítulo 4
%
%---------------------------------------------------------------------
\lstset{
	escapeinside={<@}{@>},
	frame = single, 
	language=Java}
\definecolor{mygray}{RGB}{118, 118, 118}
\definecolor{myblue}{RGB}{27, 6, 215}
\definecolor{mypurple}{RGB}{128, 75, 119}
\def\graycolor{\color{mygray}}
\def\blackcolor{\color{black}}
\def\bluecolor{\color{myblue}}
\def\purplecolor{\color{mypurple}}

\chapter{Diseño y desarrollo de la aplicación móvil}

\begin{resumen}
	En este capítulo se describen todos los aspectos relacionados al diseño y desarrollo de la aplicación en cuestión. Se desarrollará un análisis de Android, en el cual se describirán todas las características y estructura del proyecto.
	\\
	Se presentará el desarrollo realizado para llevar adelante la solución del problema principal, junto a todas las APIs y bibliotecas utilizadas en conjunto.
\end{resumen}


%-------------------------------------------------------------------
\section{Proyecto Android}
%-------------------------------------------------------------------
\label{cap4:sec:nociones-android}

Tal como fue especificado anteriormente, el desarrollo de la aplicación móvil fue llevado a cabo bajo el IDE Android Studio. Para ello, es importante describir todas las cuestiones relacionadas a un proyecto Android, con la finalidad de comprender la estructura que el mismo presenta, todos los componentes básicos, ciclos de vida, comunicación con el Web Service, entre otras cosas.

%------------------------------------------------------------------
\subsection{Componentes básicos de una aplicación Android}
%-------------------------------------------------------------------
\label{cap4:subsec:componentes-android}

Es de suma importancia comprender cuáles son los distintos componentes que se pueden encontrar en una aplicación Android típica, para luego tener un mejor análisis de la estructura que conlleva un proyecto de dicho lenguaje.
\\

Los componentes de la aplicación son bloques de creación esenciales de una aplicación para Android. Cada componente es un punto diferente a través del cual el sistema puede ingresar a la aplicación. No todos los componentes son puntos de entrada reales para el usuario y algunos son dependientes entre sí, pero cada uno existe como entidad individual y cumple un rol específico; cada uno es un bloque de creación único que ayuda a definir el comportamiento general de tu aplicación \cite{componentesAndroid}.
\\

Hay cuatro tipos diferentes de componentes de una aplicación. Cada tipo tiene un fin específico y un ciclo de vida diferente que define cómo se crea y se destruye el componente:

\begin{itemize}
	
	\item \textbf{\textit{Activities}}: una activity representa una pantalla con interfaz de usuario. Cada una de ellas tiene asignada una ventana en la cual se representa la interfaz gráfica. Para llevar adelante la construcción de la interfaz, existen componentes denominados vistas (Views) con los que se dispone de numerosos controles básicos, como por ejemplo botones, cuadros de texto, imágenes, etc.
	
	Una aplicación está formada por diversos activities, los cuales se encuentran interactuando entre sí. Existe una actividad principal (definida en el manifest como se verá más adelante), que se encarga de iniciar la aplicación.
	
	Para crear una nueva actividad, se debe crear una nueva clase Java, que hereda de \textit{Activity}, definiendo así su propia interfaz de usuario y las funcionalidades pertinentes.
	
	\item \textbf{\textit{Services}}: un servicio es un componente que se ejecuta en segundo plano para realizar operaciones prolongadas o tareas para procesos remotos. Un servicio no proporciona una interfaz de usuario. Son llamados a través de otro componente, como puede ser una Activity, y seguirán ejecutándose en segundo plano aunque la misma haya finalizado
	
	\item \textbf{\textit{Content Providers}}: es un componente destinado a compartir datos entre aplicaciones. Dichos datos pueden ser almacenados en el sistema de archivos, en una base de datos SQLite o en cualquier otro lugar que sea accesible desde la aplicación.
	
	\item \textbf{\textit{Broadcast Receiver}}: es un componente que detecta y reacciona frente a mensajes globales del sistema, como puede ser batería baja, SMS recibido, llamada perdida, etc. Además de esto, las aplicaciones también pueden iniciar mensajes; por ejemplo, para permitir que otras aplicaciones sepan que se descargaron datos al dispositivo y están disponibles para usarlos. Si bien no exhiben una interfaz de usuario, pueden crear una notificación de la barra de estado para alertar al usuario cuando se produzca un evento de mensaje.
	
\end{itemize}


%------------------------------------------------------------------
\subsection{Estructura del proyecto}
%-------------------------------------------------------------------
\label{cap4:subsec:estructura-android}

Un proyecto desarrollado en Android Studio está formado por distintos directorios, los cuales contienen recursos que se utilizarán a medida que se va desarrollando la aplicación. Dentro de las características principales que posee, se realiza una modularización en directorios y utiliza el lenguaje de programación XML, evitando de esta forma el exceso de código inútil en los ficheros Java.
\\

Tal como se puede ver en la Figura \ref{fig:estructura_proyecto}, inicialmente nos encontramos con un archivo de configuración XML denominado \textit{AndroidManifest}. Se encuentra situado en la raíz de todos los proyectos, y sirve para aplicar configuraciones básicas en la aplicación. El sistema Android accede a él antes de compilar cualquier línea de código \cite{manifest}. Dentro de las configuraciones que contiene se destacan:

\begin{itemize}
	
	\item Nombre del paquete de la aplicación, para identificarla de manera única.
	
	\item Definición de componentes como Activities, Services, Content, Providers, etc.
	
	\item Activity principal al iniciar.
	
	\item Nivel mínimo de la API que Android requiere para la aplicación.
	
	\item Nombre e ícono de la aplicación.
	
	\item Permisos que necesita la app para realizar determinadas tareas. Como por ejemplo acceder a la ubicación, internet, etc.
	
\end{itemize}

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=1\textwidth]%
		{Imagenes/Bitmap/estructuraAndroid}
		\caption{Estructura de proyecto Android}
		\label{fig:estructura_proyecto}
	\end{center}
\end{figure}

A continuación del manifest se sitúa el directorio \textit{Java}. Esta carpeta, que a su vez puede ser subdividida en distintos paquetes y subdirectorios, contiene todo el código fuente de la aplicación, activities, clases auxiliares, enumerables, interfaces, tests unitarios, etc. Inicialmente, Android Studio crea automáticamente el código básico de la pantalla principal de la aplicación, es decir el \textit{MainActivity}, que se ejecuta cuando la aplicación inicia.
\\

Luego nos encontramos con el directorio \textit{res}, es decir los recursos. Como lo dice su nombre, contiene todos los ficheros de recursos necesarios para el proyecto como imágenes, layouts, cadenas de texto, etc. Al igual que en el caso anterior, es subdividido en distintos subdirectorios, en los que se destacan los siguientes \cite{estructuraAndroid}:

\begin{itemize}
	
	\item \textbf{\textit{Drawable}}: contiene todas las imágenes y elementos gráficos utilizados por la aplicación. Para poder definir diferentes recursos dependiendo de la resolución y densidad de la pantalla del dispositivo, se encuentran varios directorios dentro de drawable.
	
	\item \textbf{\textit{Mipmap}}: contiene los íconos de la aplicación y al igual que en el caso anterior, se divide en subdirectorios de acuerdo a la resolución y densidad de pantalla. 
	
	\item \textbf{\textit{Layout}}: contiene los archivos XML relacionados a los Activities Java para la definición de la interfaz gráfica. En dichos contenedores se puede definir la estructura básica de una pantalla y agregar componentes de interacción con el usuario como ser botones, menú desplegable, campos de texto, entre otros. 
	
	De todas formas, solo es necesario definir el contenedor layout, ya que que dichos componentes también pueden ser agregados dinámicamente en los Activities (programáticamente en Java).
	
	Cada Activity se relaciona con un layout y mediante el método \textit{onCreate()} se levanta dicho archivo y se genera la pantalla, pudiendo acceder a los componentes de la misma para setear funcionalidades extra. Por ejemplo, así como dijimos que existe un \textit{MainActivity}, existe un \textit{activity\_main.xml} que es el layout asociado a esa Activity. 
	
	Cada componente posee un id, por lo tanto si se quisiera referenciar alguno de ellos para manipularlo, simplemente se debería invocarlo con el mismo.
	
	\item \textbf{\textit{Values}}: contiene otros archivos XML de importancia para la aplicación en los que se pueden definir todo tipo de valores, como por ejemplo cadenas de texto (\textit{strings.xml}), estilos (\textit{styles.xml}), colores (\textit{colours.xml}), etc. Estos valores luego pueden ser llamados desde cualquier punto de la aplicación, utilizando siempre el mismo recurso, sin necesidad de volver a redefinirlo cada vez que se lo requiera. Y si se desea realizar un cambio sobre alguno de ellos, simplemente se modifica el recurso de la carpeta value y el cambio se replica en toda la aplicación.
	
	Por ejemplo, en la aplicación del proyecto se definió un estándar para un tipo de botón. Por lo tanto en el archivo \textit{colours.xml} se definió:
	\\
	\begin{lstlisting}[escapechar=¿]
		<color ¿\aftergroup\purplecolor¿name¿\aftergroup\blackcolor¿=¿\aftergroup\bluecolor¿"mainButtonColor"¿\aftergroup\blackcolor¿>¿\aftergroup\graycolor¿#3646c1¿\aftergroup\blackcolor¿</color>
	\end{lstlisting}
	
	Entonces, cada vez que se requería colocar dicho color en un botón de la aplicación (o donde fuera necesario), simplemente se llamaba por su nombre y se aplicaba.
\end{itemize}

Finalmente se encuentran los parámetros de configuración de Gradle. Gradle básicamente es una herramienta de automatización para la construcción del proyecto, similar a Maven (herramienta utilizada en el desarrollo del Web Service). En dichos archivos, se encuentra la información necesaria para la compilación del proyecto, por ejemplo la versión del SDK de Android utilizada para compilar, la mínima versión de Android que soportará la aplicación, referencias a librerías externas utilizadas, el número de versión de la app, etc.
\\

En un proyecto pueden existir varios ficheros build.gradle, para definir determinados parámetros a distintos niveles. En este caso, podemos ver que existe un fichero build.gradle a nivel de proyecto, y otro a nivel de módulo dentro de la carpeta /app. El primero de ellos definirá parámetros globales a todos los módulos del proyecto, y el segundo sólo tendrá efecto para cada módulo en particular.
\\

Como se puede ver en la Figura \ref{fig:conf-sdk}, se establece la primer versión de la aplicación móvil, junto con la definición del SDK Android utilizado para compilar en la versión 26, correspondiente con Android 7.0 Nogaut. La versión mínima de SDK que soportará será la 19, tal como se mencionó anteriormente, se corresponde con Android 4.4 KitKat.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=1\textwidth]%
		{Imagenes/Bitmap/gradle1}
		\caption{Configuración SDK}
		\label{fig:conf-sdk}
	\end{center}
\end{figure}

A su vez, como se visualiza en la Figura \ref{fig:conf-librerias}, se encuentran todas las dependencias correspondientes a librerías externas, que se encargan de complementar el proyecto y lograr el alcance esperado. Por ejemplo, se encuentran las dependencias relacionadas para el API de Google Maps, Firebase, OpenCsv, etc.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=1\textwidth]%
		{Imagenes/Bitmap/gradle2}
		\caption{Librerías externas utilizadas}
		\label{fig:conf-librerias}
	\end{center}
\end{figure}

%------------------------------------------------------------------
\subsection{Actividades y ciclo de vida de una aplicación}
%-------------------------------------------------------------------
\label{cap4:subsec:ciclovida}

Todas las aplicaciones Android corren dentro de su propio proceso, el cual es creado junto a la aplicación y el sistema operativo es el encargado de eliminarlo cuando lo cree necesario, como por ejemplo para liberar su memoria. Tal como se puede ver, en Android el tiempo de vida de las aplicaciones se encuentra controlado por el sistema operativo y no por el usuario.
\\

Tal como se mencionó en secciones posteriores, las actividades se gestionan mediante métodos implementados en los Activity. Una aplicación contiene múltiples actividades vinculadas entre sí, donde una de ellas es especificada como principal dentro del \textit{AndroidManifest.xml}. Es decir, cuando la aplicación inicie esta será la pantalla que el usuario verá. 
\\

Cuando se inicia un Activity se coloca en el tope de una pila que contiene todas las actividades de la aplicación (``pila de actividades''), haciendo que la anterior se detenga pero sin perder sus datos. El ciclo de vida de una actividad se ve directamente afectado por su asociación con otras actividades, con sus tareas y con la pila de actividades. Tal como funcionan las pilas (mecanismo LIFO - ``Last in first out''), la última actividad en entrar será la primera en salir, por lo tanto cuando el usuario termina de interactuar con la actividad actual y presiona el botón ``Atrás'', la misma es destruida de la pila y es reanudada la actividad anterior \cite{cicloVida}.
\\

Una actividad puede existir básicamente en tres estados:

\begin{itemize}
	
	\item \textbf{\textit{Reanudada}}: La actividad se encuentra en el primer plano de la pantalla y tiene la atención del usuario. También denominada ``En Ejecución''.
	
	\item \textbf{\textit{Pausada}}: Otra actividad se encuentra en el primer plano y tiene la atención del usuario, pero esta todavía está visible. Es decir, otra actividad está por encima de esta y esa actividad es parcialmente transparente o no cubre toda la pantalla. El objeto Activity pausado se conserva en la memoria, mantiene toda la información de estado y miembro y continúa anexado al administrador de ventanas, pero el sistema puede eliminarla en situaciones en que la memoria sea extremadamente baja.
	
	\item \textbf{\textit{Detenida}}: La actividad está completamente opacada por otra actividad (ahora la actividad se encuentra en ``segundo plano''). En este caso, el objeto Activity también se conserva en memoria, mantiene toda la información de estado y miembro, pero no está anexado al administrador de ventanas. Sin embargo, ya no está visible para el usuario y el sistema puede eliminarla cuando necesite memoria en alguna otra parte.
	 
\end{itemize}

Cuando una actividad entra y sale de los diferentes estados mencionados, se notifica a través de diferentes métodos callbacks. En conjunto, estos métodos definen el ciclo de vida completo de una actividad, como se puede observar en la Figura \ref{fig:cicloVida}. Los métodos mencionados en dicha figura se explican a continuación:

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=1\textwidth]%
		{Imagenes/Bitmap/cicloVida}
		\caption{Ciclo de vida de una actividad}
		\label{fig:cicloVida}
	\end{center}
\end{figure}

\begin{itemize}
	
	\item \textbf{\textit{onCreate}}: Recibe una llamada cuando se crea la actividad por primera vez. Siempre seguido por \textit{onStart}.
	
	\item \textbf{\textit{onRestart}}: Recibe una llamada después de que se detiene la actividad, junto antes de que vuelva a iniciarse. Siempre seguido por \textit{onStart}.
	
	\item \textbf{\textit{onStart}}: Recibe una llamada justo antes de que la actividad se vuelva visible para el usuario. Seguido por \textit{onResume} si la actividad pasa a primer plano, o por \textit{onStop}.
	
	\item \textbf{\textit{onResume}}: Recibe una llamada justo antes de que la actividad comience a interactuar con el usuario. En este momento la actividad se encuentra en la parte superior de la pila de actividades, y recibe las entradas del usuario. Siempre seguido por \textit{onPause}.
	
	\item \textbf{\textit{onPause}}: Recibe una llamada cuando el sistema está a punto de reanudar otra actividad. Seguido por \textit{onResume} si la actividad vuelve al primer plano, o por \textit{onStop} si se vuelve invisible para el usuario.
	
	\item \textbf{\textit{onStop}}: Recibe una llamada cuando la actividad ya no es visible para el usuario. Esto puede ocurrir porque se la destruyó o porque se reanudó otra actividad (ya sea una actividad existente o una nueva) y la está cubriendo. Seguido por \textit{onRestart} si la actividad vuelve a interactuar con el usuario, o por \textit{onDestroy} si la actividad desaparece.
	
	\item \textbf{\textit{onDestroy}}: Recibe una llamada antes de que se destruya la actividad. Esta es la última llamada que recibirá la actividad. Se lo puede llamar porque la actividad está finalizando (alguien llamó a finish() para esa actividad), o porque el sistema destruye temporalmente esa instancia de la actividad para ahorrar espacio.
	
\end{itemize}

%------------------------------------------------------------------
\subsection{Conexión Web Service - Aplicación}
%-------------------------------------------------------------------
\label{cap4:subsec:comunicacionwsapp}

Para llevar adelante la comunicación entre la aplicación Android y el Web Service Java, se utilizó la librería \textit{HttpComponents} de la fundación Apache, la cual es agregada al proyecto con la herramienta Gradle, como todas las dependencias externas.
\\

Es un un conjunto de herramientas de componentes Java de bajo nivel centrado en HTTP y los protocolos asociados \cite{conexionws}. Brindan servicios del tipo cliente-servidor con un mínimo nivel de abstracción ya que muchas cuestiones básicas están resueltas, HttpClient y HttpCore (el primero de ellos de interés para nuestro proyecto).
\\

Aunque el paquete de java.net proporciona la funcionalidad básica para los recursos que tienen acceso vía HTTP, no proporciona flexibilidad o funcionalidad completa necesitada por muchos usos \cite{httpComponents}. En cambio, el componente HttpComponents proporciona abundantes características que pone el lado del cliente en ejecución de los estándares más recientes y de las recomendaciones del HTTP.
\\

A partir de una URL válida (visto en la sección de servicios disponibles del Web Service), la librería establece una conexión asíncrona con el servidor, esto quiere decir que las solicitudes HTTP suceden fuera del hilo de la interfaz de usuario y su respuesta se procesa una vez que llega al dispositivo en segundo plano. Esto es importante ya que no bloquea la pantalla ni la interacción con la misma.


\newpage
\thispagestyle{empty}
\mbox{ }