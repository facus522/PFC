%---------------------------------------------------------------------
%
%                          Capítulo 3
%
%---------------------------------------------------------------------
\lstset{
	escapeinside={<@}{@>},
	frame = single, 
	language=Java}
\definecolor{mygray}{RGB}{118, 118, 118}
\definecolor{myblue}{RGB}{27, 6, 215}
\definecolor{mypurple}{RGB}{128, 75, 119}
\def\graycolor{\color{mygray}}
\def\blackcolor{\color{black}}
\def\bluecolor{\color{myblue}}
\def\purplecolor{\color{mypurple}}

\chapter{Diseño y desarrollo del lado del servidor}

\begin{resumen}
En este capítulo se describen todos los aspectos relacionados al diseño y desarrollo tanto de la base de datos como del Web Service, junto a los distintos modelados y diagramas. Se presentará la arquitectura escogida de resolución.
\\
Además, se ampliará la información relativa a los frameworks utilizados en el desarrollo y su relación con las distintas capas de arquitectura.
\\
Finalmente, se presentarán todos los servicios (endpoints) que estarán disponibles en el Web Service, para luego ser consumidos por la aplicación móvil.
\end{resumen}

%-------------------------------------------------------------------
\section{Base de datos}
%-------------------------------------------------------------------
\label{cap4:sec:implementacion-db}

En base a lo expuesto en secciones anteriores, es necesario el uso de un sistema de almacenamiento para poder manejar toda la información con la que la aplicación va a trabajar. Los datos a guardar serán relacionados a los usuarios que van a interactuar con el sistema y las encuestas en sí. Los mismos serán creados y accedidos por el Web Service.
\\

En esta sección se presentará todo lo relacionado al gestor de base de datos escogido, junto al diseño del mismo.

%------------------------------------------------------------------
\subsection{Gestor de la base de datos}
%-------------------------------------------------------------------
\label{cap2:subsec:gestor-db}

Para llevar adelante la gestión de la base de datos se escogió \textit{MySQL}. Es un gestor de bases de datos relacional, considerado como la base de código abierto más popular en el mundo \cite{mysqlPopular} y la segunda más popular a nivel general, detrás de la licencia propietaria de \textit{Oracle} \cite{mysqlRanking}, sobre todo para entornos de desarrollo web.
\\

MySQL posee un esquema de doble licenciamiento, donde la base de datos se distribuye en varias versiones, una \textit{Community} distribuida bajo la licencia pública general de GNU y varias versiones \textit{Enterprise}, para aquellas empresas que quieran incorporarlo en productos privativos.
\\

Se posee gran cantidad de documentación, lo cual es de gran ayuda para resolver cualquier inconveniente que se presente. Este gestor brinda la posibilidad de desarrollar una base de datos de tipo \textit{OLTP} (On Line Transaction Processing), también llamadas bases de datos dinámicas, la cual es acorde al proyecto, ya que permite que la información sea modificada en tiempo real, pudiendo insertar, eliminar, modificar o consultar datos durante la operación del sistema, a diferencia de las bases de datos de tipo \textit{OLAP} (On Line Analytcal Processing) que son estáticas, es decir no se insertan, eliminan, ni modifican datos, sino que solamente se pueden realizar consultas sobre datos ya existentes \cite{tiposDB}.
\\

Dentro de las ventajas a mencionar en cuanto a la elección de éste gestor por sobre SQLServer u Oracle por ejemplo (dos de los gestores de base de datos más populares), MySQL es un software totalmente open source a diferencia de los mencionados y posee gran velocidad a la hora de realizar operaciones (siendo uno de los mejores rendimientos), posee bajos costos en los requerimientos para la elaboración de la base de datos, pudiendo ejecutarse en máquinas de escasos recursos gracias a su bajo consumo y existen diversos drivers para efectuar conexiones a la misma. Pero sin dudas, una de las mayores ventajas se debe a que por su conectividad, velocidad y seguridad es altamente apropiada para acceder a bases de datos a través de Internet como lo será en este proyecto.
\\

En este proyecto se trabajó con la versión Community, en los sistemas operativos Windows 10 y Ubuntu 18.04 LTS, aprovechando ésta ventaja multiplataforma que posee MySQL. Además, se utilizó \textit{MySQL Workbench}, una herramienta opcional dentro de la versión Community, con la cual se brinda un entorno visual que permite el diseño de la base de datos, administración y ejecución de consultas.

%------------------------------------------------------------------
\subsection{Modelado del problema}
%-------------------------------------------------------------------
\label{cap2:subsec:modelado-db}

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/modelo_db}
		\caption{Diseño de la base de datos}
		\label{fig:modelobd}
	\end{center}
\end{figure}

Una vez definido e instalado el gestor de base de datos escogido, se prosiguió por diseñar el modelo del problema, en donde se desglosa el problema principal en distintas entidades las cuales van a ser representadas por tablas y poseen relaciones entre ellas. El diagrama de tablas de la base de datos se presenta en la Figura \ref{fig:modelobd}.
\\

Al tratarse de una base de datos del tipo relacional, se puede notar que todas las tablas poseen un \textit{ID} el cual realiza las tareas de clave primaria o primary key (PK). Su funcionalidad es la de identificar en forma única a cada fila de una tabla, por lo que cuenta con el carácter de unicidad. La tabla \textit{Resultado\_Respuesta} es la única que no posee un ID propio, ya que simplemente representa la relación entre dos entidades.
\\

Entrando más en detalle del modelo presentado, inicialmente es conveniente realizar una descripción del manejo de usuarios. Para ello se presentan tres tablas \textit{Sexo}, \textit{Tipo\_Usuario} y \textit{Usuario}. La primera resulta de carácter intuitivo, donde simplemente se describe el género de las personas. En la segunda tabla se representa el tipo de usuario que puede adquirir una persona, donde inicialmente se establecieron ``Usuarios Específicos'' y ``Usuarios Comunes'', dejando abierta la posibilidad de introducir un nuevo rol en un futuro. En cuanto a la tercer entidad, almacena todos los datos de los usuarios que van a interactuar con la aplicación. Más allá de poseer un ID como se especificó anteriormente, tiene además otros datos con carácter de unicidad como el DNI, nombre de usuario y mail para mayor seguridad y control de los registros establecidos. 
\\

Como se puede ver, ésta tabla se relaciona con las dos primeras, es decir cada usuario tiene un género y un tipo. Así es como posee dos claves foráneas o foreign key (FK), es decir una columna de la tabla que se corresponde exactamente con una columna de otra tabla donde está definida como PK para establecer la relación.
\\

Para el modelado de las encuestas que se van a llevar a cabo, se presenta la tabla denominada \textit{Encuesta}. Dentro de los atributos que posee, cabe destacar la diferencia entre ``Activa'' y ``Habilitada''. Al producirse el alta de una de ellas, la misma queda en estado activa (true), pero no estará disponible para ser resuelta por los usuarios hasta que se encuentre habilitada. Además, se llevará a cabo una auditoria de las mismas, registrando qué usuario y en qué fecha realizó algún ABM. Cabe destacar que las eliminaciones o bajas serán del tipo lógico (poniéndolas como activo = false), con la finalidad de no perder los registros y respaldar la auditoría propiamente dicha.
\\

A su vez, la tabla de encuestas se encuentra relacionada con la entidad \textit{Pregunta}, donde se van a almacenar todas aquellas que formen parte del formulario. Es por ello que la presente tabla contiene una FK contra las encuestas y otra con la entidad \textit{Tipo\_Pregunta}. Esta última determina de qué carácter es la pregunta en relación a su respuesta, es decir si se trata de una ``Múltiple Choice'', ``Respuesta Única'', ``Desarrollo'', etc. Por lo tanto, cada pregunta va a poseer una o más respuestas dependiendo del tipo. Esta última entidad se representa en la tabla \textit{Respuesta}.
\\

A la hora de responder las encuestas, los datos obtenidos serán almacenados en la tabla \textit{Resultado}. Presenta una FK con la entidad Usuario, para determinar quién fue el encargado de la resolución. Si se trata de un usuario común, los atributos edad y sexo serán completados automáticamente por dicha relación, mientras que si se trata de un usuario específico, los datos serán introducidos manualmente a la hora de resolver una determinada encuesta. En cuando al campo ``Descripción respuesta'', se almacenará el texto respondido, si se tratara de preguntas que no poseen respuestas predefinidas como las múltiple choice, por ejemplo.
\\

Es por ello que las tablas de resultados y respuestas se encuentran relacionadas. Al tratarse de una relación ``Muchos a muchos'' o ``Many to Many'', es decir un resultado puede tener N respuestas y una respuesta estar en M resultados, la relación se almacenará en la tabla \textit{Resultado\_Respuesta}. Dicha entidad contiene solamente un PK compuesto, es decir las FK correspondientes a las dos tablas relacionadas.
\\

Por último, se encuentra aislada la tabla \textit{Informacion\_Noticia} en la que se almacenarán todas aquellas noticias e informaciones que se consideren de interés para el resto de los usuarios. Como atributos presentará un título y una descripción (ésta última opcional) y una URL que hará referencia al sitio donde se aloja la noticia en sí.
\\

Cabe aclarar que una vez creadas las tablas en la base de datos, se realizó una carga inicial mediante sentencias SQL sobre las entidades Sexo, Tipo de Usuario y Tipo de Preguntas, ya que son datos predefinidos independientes de la aplicación móvil. El resto de las tablas se irán poblando mediante los consumos que realice la app sobre Web Service.

%-------------------------------------------------------------------
\section{Web Service}
%-------------------------------------------------------------------
\label{cap4:sec:implementacion-ws}

Una vez definida e implementada la base de datos, en la presente sección se detallarán todos los aspectos relacionados al desarrollo del Web Service. Se incluye una descripción del proyecto Java, el modelado de objetos junto a los diagramas de clase, la arquitectura escogida para la resolución, frameworks utilizados y demás conceptos relacionados.

%------------------------------------------------------------------
\subsection{Proyecto Maven}
%-------------------------------------------------------------------
\label{cap2:subsec:maven}

A la hora de crear el proyecto Java encargado de realizar las funciones de Web Service, se desarrolló el mismo bajo un proyecto del tipo \textit{Maven}. Maven es una herramienta de software para la gestión y construcción de proyectos Java, desarrollada y mantenida por Apache Software Foundation al igual que Tomcat (el contenedor de servlets escogido mencionado anteriormente).
\\

Tiene un modelo de configuración de construcción basado en un archivo con formato XML. Se trata del \textit{Project Object Model} (POM) que se encarga de describir el proyecto de software a construir, sus dependencias de otros módulos y componentes externos (como por ejemplo la utilización de librerías y frameworks), y el orden de construcción de los elementos.
\\

Una de las principales características que posee Maven es su capacidad de trabajar en red. El motor incluido en su núcleo puede dinámicamente descargar plugins de un repositorio (Maven Central), el mismo repositorio que provee acceso a muchas versiones de diferentes proyectos Open Source en Java, de Apache y otras organizaciones y desarrolladores \cite{maven1}\cite{maven2}.
\\

Mediante las anotaciones realizadas en el POM, Maven automáticamente detecta los cambios y realizan descargas dinámicas de los repositorios, permitiendo no tener que instalar manualmente cada dependencia a utilizar. Como se puede ver en la Figura \ref{fig:estructura-maven}, la cual posee una estructura básica de éstos tipos de proyectos, los JAR (Java Archive) se presentan dentro del paquete \textit{Maven Dependencies}, además de ser descargados en una carpeta local oculta.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/estructura_maven}
		\caption{Estructura de proyecto Maven}
		\label{fig:estructura-maven}
	\end{center}
\end{figure}

En el proyecto, ésta herramienta sirvió de gran utilidad a la hora de descargar e instalar dependencias externas como frameworks o librerías. Permitió automatizar tareas que desde el punto de vista del desarrollador pueden llegar a demandar mayor tiempo y resultar tediosas. En la figura \ref{fig:maven-pom} se presenta un ejemplo de anotación incluido en el pom.xml para la descarga de un framework.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/anotacion_pom}
		\caption{Dependencia en pom.xml}
		\label{fig:maven-pom}
	\end{center}
\end{figure}

Dentro de las dependencias utilizadas para el desarrollo del Web Service se destacan las siguientes (las dos primeras serán explicadas con mayor detalle posteriormente):

\begin{itemize}
	
	\item Spring Framework.
	
	\item Hibernate.
	
	\item Apache Commons DBCP: permite la interacción con una base de datos relacional, por ejemplo creando conexiones para los usuarios, realizando transacciones, etc.
	
	\item Log4J: permite a la aplicación mostrar mensajes de información de lo que está sucediendo en ella, lo que habitualmente se conoce como log.
	
	\item Servlet: distribución de contenedores servlet como por ejemplo Tomcat, ya descriptos anteriormente.
	
	\item JUnit: conjunto de bibliotecas que facilitan la realización de pruebas unitarias dentro del proyecto Java.
	
	\item Gson: biblioteca que permite la serialización y deserialización entre objetos Java y su representación en notación Json.
	
	\item Json: librería para la creación de objetos Json.
	
	\item MySQL Connector: librería que permite conectar nuestro código Java con la base de datos MySQL, de forma que se puedan realizar consultas a la misma.
	
	\item Apache Commons: conjunto de proyectos de Apache Software Foundation que provee componentes de software Java reutilizables. Por ejemplo la codificación de contraseñas bajo la encriptación en Base 64.
	
	
\end{itemize}

%------------------------------------------------------------------
\subsection{Mapeo objeto-relacional}
%-------------------------------------------------------------------
\label{cap2:subsec:mapeo-objetos}

Ya con las tablas creadas en base de datos, es necesario llevar adelante el mapeo objeto-relacional o también conocido por su definición en inglés \textit{Object-Relational mapping (ORM)}. Es una técnica de programación cuya funcionalidad es la de mapear datos entre los objetos Java y la base de datos relacional utilizada como motor de persistencia. 
\\

Esto crea una base de datos orientada a objetos virtual, sobre la base de datos relacional, posibilitando el uso de las características propias de la orientación a objetos.
\\

Para llevar adelante dicho mapeo es necesario definir las clases objetivos. Por lo tanto, al igual que fue presentado en la sección anterior el modelado de la base de datos, en la Figura \ref{fig:diagrama-modelo} se presenta el modelo equivalente en diagrama de clases de Java.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/modelo_datos}
		\caption{Diagrama de clases del modelo}
		\label{fig:diagrama-modelo}
	\end{center}
\end{figure}

Tal como fue mencionado anteriormente, todas las entidades poseen un \textit{id} que hace las tareas de PK. Es por ello que se definió una clase \textit{Entity} de la que van a heredar todas las anteriores, la cual básicamente presenta un id genérico. El objetivo de la misma es abstraer el problema siguiendo las buenas prácticas de la programación orientada a objetos, indiferentemente al tipo de dato que la clase que hereda quiera manejar.
\\

A su vez, dicha entidad implementa la interfaz ``Serializable'' de Java. La serialización de un objeto consiste en convertir el mismo en una secuencia de bytes, pudiendo enviarlo a través de red, guardarlo en un fichero y después reconstruirlo al otro lado de la red.
\\

En el modelo se pueden ver las relaciones entre las distintas entidades, a través de asociaciones y composiciones según corresponda cada caso. Su análogo de representación en el modelo de base de datos eran las FK.

%------------------------------------------------------------------
\subsection{Hibernate y sus configuraciones}
%-------------------------------------------------------------------
\label{cap2:subsec:hibernate}

Para llevar adelante el mapeo objeto-relacional, se utilizó el framework \textit{Hibernate}. Es una herramienta ORM para la plataforma Java, que facilita el mapeo de atributos entre una base de datos relacional tradicional y el modelo de objetos de una aplicación, mediante archivos declarativos (XML) o anotaciones en los beans de las entidades que permiten establecer éstas relaciones \cite{hibernate1}.
\\

Busca solucionar el problema de la diferencia entre los dos modelos de datos coexistentes en una aplicación: el usado en la memoria de la computadora (orientación a objetos) y el usado en las bases de datos (modelo relacional). Para lograr esto permite al desarrollador detallar cómo es su modelo de datos, qué relaciones existen y qué forma tienen. Con esta información Hibernate le permite a la aplicación manipular los datos en la base de datos operando sobre objetos, con todas las características de la POO. 
\\

Hibernate convertirá los datos entre los tipos utilizados por Java y los definidos por SQL. Genera las sentencias SQL y libera al desarrollador del manejo manual de los datos que resultan de la ejecución de dichas sentencias, manteniendo la portabilidad entre todos los motores de bases de datos con un ligero incremento en el tiempo de ejecución \cite{hibernate2}.
\\

Ofrece también un lenguaje de consulta de datos llamado \textit{HQL} (Hibernate Query Language), al mismo tiempo que una API para construir las consultas programáticamente, conocida como \textit{Criteria}.
\\

En cuanto a la configuración, inicialmente se debe establecer la conexión entre la base de datos y la aplicación mediante una URL. Dicha conexión se encarga de realizarla la librería Apache Commons DBCP, mencionada anteriormente. Al tratarse del gestor MySQL corriendo de manera local, la URL a establecer es: \textit{http://localhost:3306/pfc\_encuestas}. Donde \textit{pfc\_encuestas} es el nombre de la base de datos y 3306 el puerto por defecto que ocupa MySQL. En adición, se debe definir el usuario, contraseña y el driver de conexión que depende del tipo de base de datos, en este caso \textit{com.mysql.jdbc.Driver}.
\\

Es necesario establecer el paquete Java que contiene todas las clases a mapear, mediante la propiedad \textit{packagesToScan}. Por lo tanto, dentro de la subdivisión de paquetes (de la cual se hablará en secciones posteriores), todas las clases que representan el modelo se encuentran en \textit{com.fsalmeron.encuestasfcm.model}.
\\

Todas éstas configuraciones y muchas más \footnote{http://hibernate.org/} son llevadas a cabo en un archivo del tipo XML denominado \textit{servlet-context}.
\\

Para realizar el mapeo ORM, se escogió la técnica de anotaciones en lugar de archivos de mapeos XML, la cual es proporcionada por el framework y denominada ``Hibernate Annotations''.
\\

Inicialmente se colocan dos anotaciones a nivel clase muy importantes: en primer lugar se especifica \textbf{\textit{@Entity}}, la cual indica que la clase es una entidad, es decir un objeto Java que puede ser persistido. Seguido a ella se coloca la anotación \textbf{\textit{@Table}}, la cual especifica el nombre de la tabla en base de datos que se debe apuntar.

\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@Entity¿\aftergroup\blackcolor¿ (name = ¿\aftergroup\bluecolor¿"TIPO_USUARIO"¿\aftergroup\blackcolor¿)
	¿\aftergroup\graycolor¿@Table¿\aftergroup\blackcolor¿ (name = ¿\aftergroup\bluecolor¿"TIPO_USUARIO"¿\aftergroup\blackcolor¿)
	¿\aftergroup\purplecolor¿public class¿\aftergroup\blackcolor¿ TipoUsuario ¿\aftergroup\purplecolor¿extends ¿\aftergroup\blackcolor¿Entity<Integer>
\end{lstlisting}

A continuación, se especifican todas las anotaciones de carácter individual, es decir todas aquellas que se realizan sobre un determinado atributo o sobre la función \textit{get()} del mismo.
\\

Para indicar cuál atributo de la clase será el identificador, es decir el Primary Key, se utiliza la anotación \textbf{\textit{@Id}}. Seguido a ella, se puede personalizar la forma en que se generará el valor del identificador mediante la anotación \textbf{\textit{@GeneratedValue}}. Existen cuatro estrategias de generación: AUTO, IDENTITY, SEQUENCE y TABLE\footnote{http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/GeneratedValue.html}, donde la primer opción fue la escogida en el proyecto, ya que utiliza la estrategia por defecto de la base de datos. Además, es necesario agregar la anotación \textbf{\textit{@SequenceGenerator}} la cual define un generador de clave primaria que es referenciado por el GeneratedValue.

\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@Id
	@GeneratedValue¿\aftergroup\blackcolor¿(strategy = GenerationType.¿\aftergroup\bluecolor¿AUTO¿\aftergroup\blackcolor¿, 
			generator = ¿\aftergroup\bluecolor¿"Sexo_Generator"¿\aftergroup\blackcolor¿)
	¿\aftergroup\graycolor¿@SequenceGenerator¿\aftergroup\blackcolor¿(name = ¿\aftergroup\bluecolor¿"Sexo_Generator"¿\aftergroup\blackcolor¿, 
			sequenceName = ¿\aftergroup\bluecolor¿"Sexo_Generator"¿\aftergroup\blackcolor¿)
	¿\aftergroup\purplecolor¿public¿\aftergroup\blackcolor¿ Integer getId() {
		¿\aftergroup\purplecolor¿return¿\aftergroup\blackcolor¿ id;
	}
\end{lstlisting}

Todos aquellos atributos que no estén marcados como \textbf{\textit{@Transient}}, serán persistidos. Para llevar adelante la personalización de la columna de la tabla en un determinado atributo se utiliza la anotación \textbf{\textit{@Column}}. Dentro de ella se puede especificar por ejemplo el nombre de la columna en base de datos, si es una clave única, si puede ser null, etc\footnote{http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/Column.html}.

\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@Column¿\aftergroup\blackcolor¿(name = ¿\aftergroup\bluecolor¿"DNI"¿\aftergroup\blackcolor¿, nullable = ¿\aftergroup\purplecolor¿false¿\aftergroup\blackcolor¿, unique = ¿\aftergroup\purplecolor¿true¿\aftergroup\blackcolor¿)
	¿\aftergroup\purplecolor¿public¿\aftergroup\blackcolor¿ Integer getDni() {
		¿\aftergroup\purplecolor¿return¿\aftergroup\blackcolor¿ dni;
	}
\end{lstlisting}

A la hora de mapear las relaciones que se producen entre las entidades, hay que tener en cuenta como se dá la misma para escoger la anotación adecuada. Por ejemplo, en la relación que se encuentra entre la entidad Respuesta y Pregunta, donde la primera tiene una FK sobre la segunda, el mapeo de la misma estará dado mediante la anotación \textbf{\textit{@ManyToOne}}. Dentro de ella se puede especificar entre otras cosas la estrategia para obtener datos de la base de datos, en este caso LAZY, es decir trae la información cuando la necesita. Seguido a ésta anotación, se debe colocar \textbf{\textit{@JoinColumn}}, la cual permite unir dos columnas de una tabla con las FK correspondientes.

\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@ManyToOne¿\aftergroup\blackcolor¿(fetch = FetchType.¿\aftergroup\bluecolor¿LAZY¿\aftergroup\blackcolor¿)
	¿\aftergroup\graycolor¿@JoinColumn¿\aftergroup\blackcolor¿(name = ¿\aftergroup\bluecolor¿"IDPREGUNTA"¿\aftergroup\blackcolor¿)
	¿\aftergroup\purplecolor¿public¿\aftergroup\blackcolor¿ Pregunta getPregunta() {
		¿\aftergroup\purplecolor¿return¿\aftergroup\blackcolor¿ pregunta;
	}
\end{lstlisting}

En este caso se realizó un mapeo unidireccional, es decir se introdujo la anotación solamente en la entidad Respuesta. También se podría haber especificado desde el lado de Preguntas, aunque en éste caso la relación sería con \textbf{\textit{@OneToMany}}. Si se presentan las anotaciones de ambos lados se dice que el mapeo es bidireccional.
\\

Por último, para la asociación entre Respuesta y Resultados, la cual presentaba una tabla extra por tratarse de una relación muchos a muchos, es mapeada bajo la anotación \textbf{\textit{@ManyToMany}}. En este caso se agregará la anotación \textbf{\textit{@JoinTable}} para ésta tabla extra, y dentro de ella se encuentra el \textbf{\textit{@JoinColumn}} especificado anteriormente.

\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@ManyToMany¿\aftergroup\blackcolor¿(fetch = FetchType.¿\aftergroup\bluecolor¿LAZY¿\aftergroup\blackcolor¿)
	¿\aftergroup\graycolor¿@JoinTable¿\aftergroup\blackcolor¿(name = ¿\aftergroup\bluecolor¿"RESULTADO_RESPUESTA"¿\aftergroup\blackcolor¿), 
		joinColumns = {¿\aftergroup\graycolor¿@JoinColumn¿\aftergroup\blackcolor¿(name = ¿\aftergroup\bluecolor¿"RESULTADO"¿\aftergroup\blackcolor¿) }, 
		inverseJoinColumns = {¿\aftergroup\graycolor¿@JoinColumn¿\aftergroup\blackcolor¿(name = ¿\aftergroup\bluecolor¿"RESPUESTA"¿\aftergroup\blackcolor¿)})
	¿\aftergroup\purplecolor¿public¿\aftergroup\blackcolor¿ List<Respuesta> getRespuestas(){
		¿\aftergroup\purplecolor¿return¿\aftergroup\blackcolor¿ respuestas;
	}
\end{lstlisting}

\newpage
\thispagestyle{empty}
\mbox{ }