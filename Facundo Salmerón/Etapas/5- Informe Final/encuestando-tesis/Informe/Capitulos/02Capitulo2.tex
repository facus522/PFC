%---------------------------------------------------------------------
%
%                          Capítulo 4
%
%---------------------------------------------------------------------
\lstset{
	escapeinside={<@}{@>},
	frame = single, 
	language=Java}
\definecolor{mygray}{RGB}{118, 118, 118}
\definecolor{myblue}{RGB}{27, 6, 215}
\definecolor{mypurple}{RGB}{128, 75, 119}
\def\graycolor{\color{mygray}}
\def\blackcolor{\color{black}}
\def\bluecolor{\color{myblue}}
\def\purplecolor{\color{mypurple}}

\chapter{Diseño y desarrollo de la aplicación móvil}

\begin{resumen}
	En este capítulo se describen todos los aspectos relacionados al diseño y desarrollo de la aplicación en cuestión. Se desarrollará un análisis de Android, en el cual se describirán todas las características y estructura del proyecto.
	\\
	Se presentará el desarrollo realizado para llevar adelante la solución del problema principal, junto a todas las APIs y bibliotecas utilizadas en conjunto.
\end{resumen}


%-------------------------------------------------------------------
\section{Proyecto Android}
%-------------------------------------------------------------------
\label{cap4:sec:nociones-android}

Tal como fue especificado anteriormente, el desarrollo de la aplicación móvil fue llevado a cabo bajo el IDE Android Studio. Para ello, es importante describir todas las cuestiones relacionadas a un proyecto Android, con la finalidad de comprender la estructura que el mismo presenta, todos los componentes básicos, ciclos de vida, comunicación con el Web Service, entre otras cosas.

%------------------------------------------------------------------
\subsection{Componentes básicos de una aplicación Android}
%-------------------------------------------------------------------
\label{cap4:subsec:componentes-android}

Es de suma importancia comprender cuáles son los distintos componentes que se pueden encontrar en una aplicación Android típica, para luego tener un mejor análisis de la estructura que conlleva un proyecto de dicho lenguaje.
\\

Los componentes de la aplicación son bloques de creación esenciales de una aplicación para Android. Cada componente es un punto diferente a través del cual el sistema puede ingresar a la aplicación. No todos los componentes son puntos de entrada reales para el usuario y algunos son dependientes entre sí, pero cada uno existe como entidad individual y cumple un rol específico; cada uno es un bloque de creación único que ayuda a definir el comportamiento general de tu aplicación \cite{componentesAndroid}.
\\

Hay cuatro tipos diferentes de componentes de una aplicación. Cada tipo tiene un fin específico y un ciclo de vida diferente que define cómo se crea y se destruye el componente:

\begin{itemize}
	
	\item \textbf{\textit{Activities}}: una activity representa una pantalla con interfaz de usuario. Cada una de ellas tiene asignada una ventana en la cual se representa la interfaz gráfica. Para llevar adelante la construcción de la interfaz, existen componentes denominados vistas (Views) con los que se dispone de numerosos controles básicos, como por ejemplo botones, cuadros de texto, imágenes, etc.
	
	Una aplicación está formada por diversos activities, los cuales se encuentran interactuando entre sí. Existe una actividad principal (definida en el manifest como se verá más adelante), que se encarga de iniciar la aplicación.
	
	Para crear una nueva actividad, se debe crear una nueva clase Java, que hereda de \textit{Activity}, definiendo así su propia interfaz de usuario y las funcionalidades pertinentes.
	
	\item \textbf{\textit{Services}}: un servicio es un componente que se ejecuta en segundo plano para realizar operaciones prolongadas o tareas para procesos remotos. Un servicio no proporciona una interfaz de usuario. Son llamados a través de otro componente, como puede ser una Activity, y seguirán ejecutándose en segundo plano aunque la misma haya finalizado
	
	\item \textbf{\textit{Content Providers}}: es un componente destinado a compartir datos entre aplicaciones. Dichos datos pueden ser almacenados en el sistema de archivos, en una base de datos SQLite o en cualquier otro lugar que sea accesible desde la aplicación.
	
	\item \textbf{\textit{Broadcast Receiver}}: es un componente que detecta y reacciona frente a mensajes globales del sistema, como puede ser batería baja, SMS recibido, llamada perdida, etc. Además de esto, las aplicaciones también pueden iniciar mensajes; por ejemplo, para permitir que otras aplicaciones sepan que se descargaron datos al dispositivo y están disponibles para usarlos. Si bien no exhiben una interfaz de usuario, pueden crear una notificación de la barra de estado para alertar al usuario cuando se produzca un evento de mensaje.
	
\end{itemize}


%------------------------------------------------------------------
\subsection{Estructura del proyecto}
%-------------------------------------------------------------------
\label{cap4:subsec:estructura-android}

Un proyecto desarrollado en Android Studio está formado por distintos directorios, los cuales contienen recursos que se utilizarán a medida que se va desarrollando la aplicación. Dentro de las características principales que posee, se realiza una modularización en directorios y utiliza el lenguaje de programación XML, evitando de esta forma el exceso de código inútil en los ficheros Java.
\\

Tal como se puede ver en la Figura \ref{fig:estructura_proyecto}, inicialmente nos encontramos con un archivo de configuración XML denominado \textit{AndroidManifest}. Se encuentra situado en la raíz de todos los proyectos, y sirve para aplicar configuraciones básicas en la aplicación. El sistema Android accede a él antes de compilar cualquier línea de código \cite{manifest}. Dentro de las configuraciones que contiene se destacan:

\begin{itemize}
	
	\item Nombre del paquete de la aplicación, para identificarla de manera única.
	
	\item Definición de componentes como Activities, Services, Content, Providers, etc.
	
	\item Activity principal al iniciar.
	
	\item Nivel mínimo del API que Android requiere para la aplicación.
	
	\item Nombre e ícono de la aplicación.
	
	\item Permisos que necesita la app para realizar determinadas tareas. Como por ejemplo acceder a la ubicación, internet, etc.
	
\end{itemize}

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=1\textwidth]%
		{Imagenes/Bitmap/estructuraAndroid}
		\caption{Estructura de proyecto Android}
		\label{fig:estructura_proyecto}
	\end{center}
\end{figure}

A continuación del manifest se sitúa el directorio \textit{Java}. Esta carpeta, que a su vez puede ser subdividida en distintos paquetes y subdirectorios, contiene todo el código fuente de la aplicación, activities, clases auxiliares, enumerables, interfaces, tests unitarios, etc. Inicialmente, Android Studio crea automáticamente el código básico de la pantalla principal de la aplicación, es decir el \textit{MainActivity}, que se ejecuta cuando la aplicación inicia.
\\

Luego nos encontramos con el directorio \textit{res}, es decir los recursos. Como lo dice su nombre, contiene todos los ficheros de recursos necesarios para el proyecto como imágenes, layouts, cadenas de texto, etc. Al igual que en el caso anterior, es subdividido en distintos subdirectorios, en los que se destacan los siguientes \cite{estructuraAndroid}:

\begin{itemize}
	
	\item \textbf{\textit{Drawable}}: contiene todas las imágenes y elementos gráficos utilizados por la aplicación. Para poder definir diferentes recursos dependiendo de la resolución y densidad de la pantalla del dispositivo, se encuentran varios directorios dentro de drawable.
	
	\item \textbf{\textit{Mipmap}}: contiene los íconos de la aplicación y al igual que en el caso anterior, se divide en subdirectorios de acuerdo a la resolución y densidad de pantalla. 
	
	\item \textbf{\textit{Layout}}: contiene los archivos XML relacionados a los Activities Java para la definición de la interfaz gráfica. En dichos contenedores se puede definir la estructura básica de una pantalla y agregar componentes de interacción con el usuario como ser botones, menú desplegable, campos de texto, entre otros. 
	
	De todas formas, solo es necesario definir el contenedor layout, ya que que dichos componentes también pueden ser agregados dinámicamente en los Activities (programáticamente en Java).
	
	Cada Activity se relaciona con un layout y mediante el método \textit{onCreate()} se levanta dicho archivo y se genera la pantalla, pudiendo acceder a los componentes de la misma para setear funcionalidades extra. Por ejemplo, así como dijimos que existe un \textit{MainActivity}, existe un \textit{activity\_main.xml} que es el layout asociado a esa Activity. 
	
	Cada componente posee un id, por lo tanto si se quisiera referenciar alguno de ellos para manipularlo, simplemente se debería invocarlo con el mismo.
	
	\item \textbf{\textit{Values}}: contiene otros archivos XML de importancia para la aplicación en los que se pueden definir todo tipo de valores, como por ejemplo cadenas de texto (\textit{strings.xml}), estilos (\textit{styles.xml}), colores (\textit{colours.xml}), etc. Estos valores luego pueden ser llamados desde cualquier punto de la aplicación, utilizando siempre el mismo recurso, sin necesidad de volver a redefinirlo cada vez que se lo requiera. Y si se desea realizar un cambio sobre alguno de ellos, simplemente se modifica el recurso de la carpeta value y el cambio se replica en toda la aplicación.
	
	Por ejemplo, en la aplicación del proyecto se definió un estándar para un tipo de botón. Por lo tanto en el archivo \textit{colours.xml} se definió:
	\\
	\begin{lstlisting}[escapechar=¿]
		<color ¿\aftergroup\purplecolor¿name¿\aftergroup\blackcolor¿=¿\aftergroup\bluecolor¿"mainButtonColor"¿\aftergroup\blackcolor¿>¿\aftergroup\graycolor¿#3646c1¿\aftergroup\blackcolor¿</color>
	\end{lstlisting}
	
	Entonces, cada vez que se requería colocar dicho color en un botón de la aplicación (o donde fuera necesario), simplemente se llamaba por su nombre y se aplicaba.
\end{itemize}

Finalmente se encuentran los parámetros de configuración de Gradle. Gradle básicamente es una herramienta de automatización para la construcción del proyecto, similar a Maven (herramienta utilizada en el desarrollo del Web Service). En dichos archivos, se encuentra la información necesaria para la compilación del proyecto, por ejemplo la versión del SDK de Android utilizada para compilar, la mínima versión de Android que soportará la aplicación, referencias a librerías externas utilizadas, el número de versión de la app, etc.
\\

En un proyecto pueden existir varios ficheros build.gradle, para definir determinados parámetros a distintos niveles. En este caso, podemos ver que existe un fichero build.gradle a nivel de proyecto, y otro a nivel de módulo dentro de la carpeta /app. El primero de ellos definirá parámetros globales a todos los módulos del proyecto, y el segundo sólo tendrá efecto para cada módulo en particular.
\\

Como se puede ver en la Figura \ref{fig:conf-sdk}, se establece la primer versión de la aplicación móvil, junto con la definición del SDK Android utilizado para compilar en la versión 26, correspondiente con Android 7.0 Nogaut. La versión mínima de SDK que soportará será la 19, tal como se mencionó anteriormente, se corresponde con Android 4.4 KitKat.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=1\textwidth]%
		{Imagenes/Bitmap/gradle1}
		\caption{Configuración SDK}
		\label{fig:conf-sdk}
	\end{center}
\end{figure}

A su vez, como se visualiza en la Figura \ref{fig:conf-librerias}, se encuentran todas las dependencias correspondientes a librerías externas, que se encargan de complementar el proyecto y lograr el alcance esperado. Por ejemplo, se encuentran las dependencias relacionadas para el API de Google Maps, Firebase, OpenCsv, etc.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=1\textwidth]%
		{Imagenes/Bitmap/gradle2}
		\caption{Librerías externas utilizadas}
		\label{fig:conf-librerias}
	\end{center}
\end{figure}

%------------------------------------------------------------------
\subsection{Actividades y ciclo de vida de una aplicación}
%-------------------------------------------------------------------
\label{cap4:subsec:ciclovida}

Todas las aplicaciones Android corren dentro de su propio proceso, el cual es creado junto a la aplicación y el sistema operativo es el encargado de eliminarlo cuando lo cree necesario, como por ejemplo para liberar su memoria. Tal como se puede ver, en Android el tiempo de vida de las aplicaciones se encuentra controlado por el sistema operativo y no por el usuario.
\\

Tal como se mencionó en secciones posteriores, las actividades se gestionan mediante métodos implementados en los Activity. Una aplicación contiene múltiples actividades vinculadas entre sí, donde una de ellas es especificada como principal dentro del \textit{AndroidManifest.xml}. Es decir, cuando la aplicación inicie esta será la pantalla que el usuario verá. 
\\

Cuando se inicia un Activity se coloca en el tope de una pila que contiene todas las actividades de la aplicación (``pila de actividades''), haciendo que la anterior se detenga pero sin perder sus datos. El ciclo de vida de una actividad se ve directamente afectado por su asociación con otras actividades, con sus tareas y con la pila de actividades. Tal como funcionan las pilas (mecanismo LIFO - ``Last in first out''), la última actividad en entrar será la primera en salir, por lo tanto cuando el usuario termina de interactuar con la actividad actual y presiona el botón ``Atrás'', la misma es destruida de la pila y es reanudada la actividad anterior \cite{cicloVida}.
\\

Una actividad puede existir básicamente en tres estados:

\begin{itemize}
	
	\item \textbf{\textit{Reanudada}}: La actividad se encuentra en el primer plano de la pantalla y tiene la atención del usuario. También denominada ``En Ejecución''.
	
	\item \textbf{\textit{Pausada}}: Otra actividad se encuentra en el primer plano y tiene la atención del usuario, pero esta todavía está visible. Es decir, otra actividad está por encima de esta y esa actividad es parcialmente transparente o no cubre toda la pantalla. El objeto Activity pausado se conserva en la memoria, mantiene toda la información de estado y miembro y continúa anexado al administrador de ventanas, pero el sistema puede eliminarla en situaciones en que la memoria sea extremadamente baja.
	
	\item \textbf{\textit{Detenida}}: La actividad está completamente opacada por otra actividad (ahora la actividad se encuentra en ``segundo plano''). En este caso, el objeto Activity también se conserva en memoria, mantiene toda la información de estado y miembro, pero no está anexado al administrador de ventanas. Sin embargo, ya no está visible para el usuario y el sistema puede eliminarla cuando necesite memoria en alguna otra parte.
	 
\end{itemize}

Cuando una actividad entra y sale de los diferentes estados mencionados, se notifica a través de diferentes métodos callbacks. En conjunto, estos métodos definen el ciclo de vida completo de una actividad, como se puede observar en la Figura \ref{fig:cicloVida}. Los métodos mencionados en dicha figura se explican a continuación:

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=1\textwidth]%
		{Imagenes/Bitmap/cicloVida}
		\caption{Ciclo de vida de una actividad}
		\label{fig:cicloVida}
	\end{center}
\end{figure}

\begin{itemize}
	
	\item \textbf{\textit{onCreate}}: Recibe una llamada cuando se crea la actividad por primera vez. Siempre seguido por \textit{onStart}.
	
	\item \textbf{\textit{onRestart}}: Recibe una llamada después de que se detiene la actividad, junto antes de que vuelva a iniciarse. Siempre seguido por \textit{onStart}.
	
	\item \textbf{\textit{onStart}}: Recibe una llamada justo antes de que la actividad se vuelva visible para el usuario. Seguido por \textit{onResume} si la actividad pasa a primer plano, o por \textit{onStop}.
	
	\item \textbf{\textit{onResume}}: Recibe una llamada justo antes de que la actividad comience a interactuar con el usuario. En este momento la actividad se encuentra en la parte superior de la pila de actividades, y recibe las entradas del usuario. Siempre seguido por \textit{onPause}.
	
	\item \textbf{\textit{onPause}}: Recibe una llamada cuando el sistema está a punto de reanudar otra actividad. Seguido por \textit{onResume} si la actividad vuelve al primer plano, o por \textit{onStop} si se vuelve invisible para el usuario.
	
	\item \textbf{\textit{onStop}}: Recibe una llamada cuando la actividad ya no es visible para el usuario. Esto puede ocurrir porque se la destruyó o porque se reanudó otra actividad (ya sea una actividad existente o una nueva) y la está cubriendo. Seguido por \textit{onRestart} si la actividad vuelve a interactuar con el usuario, o por \textit{onDestroy} si la actividad desaparece.
	
	\item \textbf{\textit{onDestroy}}: Recibe una llamada antes de que se destruya la actividad. Esta es la última llamada que recibirá la actividad. Se lo puede llamar porque la actividad está finalizando (alguien llamó a finish() para esa actividad), o porque el sistema destruye temporalmente esa instancia de la actividad para ahorrar espacio.
	
\end{itemize}

%------------------------------------------------------------------
\subsection{Conexión Web Service - Aplicación}
%-------------------------------------------------------------------
\label{cap4:subsec:comunicacionwsapp}

Para llevar adelante la comunicación entre la aplicación Android y el Web Service Java, se utilizó la librería \textit{HttpComponents} de la fundación Apache, la cual es agregada al proyecto con la herramienta Gradle, como todas las dependencias externas.
\\

Es un un conjunto de herramientas de componentes Java de bajo nivel centrado en HTTP y los protocolos asociados \cite{conexionws}. Brindan servicios del tipo cliente-servidor con un mínimo nivel de abstracción ya que muchas cuestiones básicas están resueltas, HttpClient y HttpCore (el primero de ellos de interés para nuestro proyecto).
\\

Aunque el paquete de java.net proporciona la funcionalidad básica para los recursos que tienen acceso vía HTTP, no proporciona flexibilidad o funcionalidad completa necesitada por muchos usos \cite{httpComponents}. En cambio, el componente HttpComponents proporciona abundantes características que pone el lado del cliente en ejecución de los estándares más recientes y de las recomendaciones del HTTP.
\\

A partir de una URL válida (visto en la sección de servicios disponibles del Web Service), la librería establece una conexión asíncrona con el servidor, esto quiere decir que las solicitudes HTTP suceden fuera del hilo de la interfaz de usuario y su respuesta se procesa una vez que llega al dispositivo en segundo plano. Esto es importante ya que no bloquea la pantalla ni la interacción con la misma.

%------------------------------------------------------------------
\subsection{Interfaz de usuario}
%-------------------------------------------------------------------
\label{cap4:subsec:interfaz-usuario}

La interfaz de usuario (UI) es una parte fundamental de las aplicaciones Android. Es el conjunto de elementos que permiten al usuario comunicarse e interaccionar con la app.  Al igual que cualquier otro componente, la UI puede ser definida en XML y levantada por el MainActivity.
\\

Android Studio brinda la posibilidad de desarrollar aplicaciones en base a plantillas predefinidas, como por ejemplo pantallas de login, pantallas fullscreen, scrolleables, mapas, etc. A las cuales se les pueden agregar distintos controles de selección ofrecidos por el IDE, ya sea para mostrar o interactuar con la información, como pueden ser listas, tablas, checks, botones, listas desplegables, galerías, etc.
\\

Además, tal como fue mencionado anteriormente, cada vez que se desee crear una nueva pantalla se generará el archivo \textit{.xml} y el Activity \textit{.Java}, ambos relacionados. Para llevar adelante el diseño de la misma, Android Studio brinda la posibilidad de realizarlo mediante código xml y presentando una ventana de actualización automática \textit{Preview} para ir verificando visualmente lo realizado. O puede diseñarse mediante un panel de construcción, donde es posible ir arrastrando y ubicando manualmente los componentes a utilizar, lo cual es mucho más sencillo.

%-------------------------------------------------------------------
\section{Geo posicionamiento}
%-------------------------------------------------------------------
\label{cap4:sec:geoposicionamiento}

Para todas aquellas encuestas que sean del tipo ``Geolocalizadas'', cuando el usuario de resolución se encuentra en su residencia habitual, es necesario obtener los datos de su ubicación mediante el componente GPS del dispositivo móvil. Inicialmente es necesario que el usuario acepte los permisos que se presentarán para la utilización del mismo.
\\

Para ello se utilizó la funcionalidad \textit{LocationServices}, brindada por Google Services \cite{locationservice}. Esta se encarga de monitorear la posición del móvil a través del sensor GPS y la conexión a redes. Al momento de responder la encuesta tiene que estar activado el sensor y los permisos aceptados, donde finalmente se podrán obtener los datos en relación a la localización, principalmente la latitud y longitud que serán persistidos.

%-------------------------------------------------------------------
\section{Servicios externos}
%-------------------------------------------------------------------
\label{cap4:sec:servicios-externas}

Para llevar adelante todas las peticiones establecidas en el proyecto, fue necesaria la integración de distintos componentes encargados de complementar todos los servicios prestados por el IDE Android Studio. 
\\

De esta forma, las distintas librerías y/o APIs utilizadas fueron anotadas en el \textit{build.gradle}, tal como se mencionó previamente. Obteniendo de esta forma la resolución de distintas cuestiones relacionadas al proyecto, sin tener que desarrollar manualmente cada una de ellas, lo cual incrementaría el tiempo de trabajo.
\\

En la ésta sección se hará una presentación más amplia sobre cada una de ellas, en relación a lo presentado en la Sección \ref{cap2:subsec:apis}.

%------------------------------------------------------------------
\subsection{API Firebase}
%-------------------------------------------------------------------
\label{cap4:subsec:firebase}

Firebase es una plataforma móvil creada por Google, cuya principal función es desarrollar y facilitar la creación de aplicaciones de alta calidad, con la finalidad de poder aumentar la cantidad de usuarios e ingresos de dinero \cite{firebase1}. Se encuentra subida en la nube y esta disponible para diferentes plataformas como iOS, Android y web.
\\

Dentro de las principales características que posee, en cuanto al desarrollo podemos mencionar que permite la creación de mejores aplicaciones, minimizando el tiempo de optimización y desarrollo, mediante diferentes funciones, entre las que destacan la detección de errores y de testeo. Además, permite almacenar todo en la nube, testear la app o poder configurarla de manera remota.
\\

Desde el punto de vista analítico, permite llevar un control de rendimiento de la aplicación mediante distintas métricas, ofrecidas en un panel web de forma gratuita. Estos datos analíticos que ofrece Firebase, facilitan la toma de decisiones basadas y fundamentadas en datos reales \cite{firebase3}.
\\

Como se puede ver, ésta API presenta una gran variedad de servicios que facilitan el desarrollo de aplicaciones móviles. Entre las más destacadas se presentan las siguientes \cite{firebase2}:

\begin{itemize}
	
	\item Base de datos Realtime.
	
	\item Autenticación con redes sociales.
	
	\item Almacenamiento.
	
	\item Hosting.
	
	\item Testing para Android.
	
	\item Notificaciones.
	
	\item Informes sobre fallos.
	
	\item Monitoreo de rendimientos.
	
\end{itemize}

Dentro de las funcionalidades ofrecidas, la de notificaciones fue de interés en este proyecto. Para ello, Firebase presenta de manera muy sencilla un servicio de mensajería, donde a la hora de enviar notificaciones, el administrador de la aplicación debe ingresar a la web de desarrollo \textit{https://console.firebase.google.com} y configurar la misma. 
\\

Luego, en la sección \textit{Cloud Messaging} como se puede ver en la Figura \ref{fig:notifirebase}, se le debe dar el formato a la notificación colocando un título y una descripción, entre otras configuraciones opcionales. Finalmente, la misma es enviada de forma inmediata hacia todos los dispositivos que tengan instalada la aplicación. 

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=1\textwidth]%
		{Imagenes/Bitmap/notifirebase}
		\caption{Envío de notificación con API Firebase}
		\label{fig:notifirebase}
	\end{center}
\end{figure}

Además, se puede configurar el envío de notificaciones hacia determinados dispositivos, programar horarios y enviarlas de manera automática.

%------------------------------------------------------------------
\subsection{API Google Maps y Picker}
%-------------------------------------------------------------------
\label{cap4:subsec:googleapi}

Google provee una serie de servicios de gran utildad para llevar adelante el desarrollo de aplicaciones Android. Para poder acceder a las distintas herramientas como pueden ser Google Maps y Picker, se debe contar con una key provista por Google. Esta es una cadena de caracteres alfanuméricos provista a un desarrollador para poder incluirlas en sus productos.
\\

Para poder utilizar ambas APIs en Android, es necesario definir en el \textit{AndroidManifest.xml} la API Key obtenida y la versión de Google Play Services que se está utilizando. Además, se debe agregar un permiso para recibir mapas a través de Internet.
\\

El API Picker, presenta un SDK para Android denominado \textit{Place Picker} (selector de lugares) \cite{picker}. Es un widget simple y flexible, que presenta mediante interfaz de usuario un mapa interactivo y una lista de lugares cercanos. Los usuarios pueden elegir una ubicación presionando sobre el mapa, lo cual creará un marcador y el API se encargará de recuperar los detalles del mismo, como dirección, latitud, longitud, etc (Figura \ref{fig:placepicker}). A su vez, tiene integrada una barra de búsqueda que permite ingresar manualmente una dirección y el API se encarga de localizarla en el mapa y colocar un marcador sobre ella.
\\

Los \textit{markers} (marcadores), indican ubicaciones únicas en el mapa y se posicionan a partir de la latitud y longitud. Los mismos pueden contener un título e imágenes. 

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.35\textwidth]%
		{Imagenes/Bitmap/placepicker}
		\caption{Selección de ubicación en Place Picker}
		\label{fig:placepicker}
	\end{center}
\end{figure}

Esta funcionalidad es de utilidad en el proyecto, ya que las encuestas tendrán la posibilidad de ser geolocalizadas. Cuando los usuarios al responder las mismas se encuentran en sus residencias habituales, mediante los servicios de Google y el componente GPS del dispositivo móvil mencionado anteriormente, se obtienen los datos de localización. En cambio, cuando no se encuentren en ellas, se les pedirá que introduzcan manualmente sus datos de residencia para mayor integridad en los datos, y es ahí que se utilizará el servicio presentado para resolver dicha cuestión.
\\

En cuanto al API de Google Maps, permite al desarrollador agregar un mapa basado en los datos de Google Maps en la pantalla de la aplicación e interactuar con él de la misma forma que se realiza en una computadora. El API controla automáticamente el acceso a los servidores de Google, la descarga de datos, visualización del mapa y respuestas \cite{maps}.
\\

Así como se permite la interacción del usuario con el mapa, pudiendo desplazarse, realizar zoom y cambiar la clase de mapa (normal, satélite o tierra), se permite agregar ciertos elementos dentro del mapa, como por ejemplo marcadores (markers), polilíneas, polígonos y superposiciones de mapas (overlays).
\\

En relación al proyecto, se aprovechan las facilidades ofrecidas por el API de Google Maps para la presentación de estadísticas interactivas. Todas aquellas encuestas geolocalizadas que hayan sido resueltas en al menos una oportunidad, brindarán una sección de estadísticas instantáneas para los ``Usuario Específicos''. Gracias a la latitud y longitud recopilada durante su resolución, es posible crear marcadores dentro de los mapas ubicando las respuestas de los usuarios. A simple vista las respuestas del mismo tipo serán agrupadas con marcadores del mismo color y dentro de la descripción en cada uno de ellos se presentará el sexo y edad del encuestado.

%------------------------------------------------------------------
\subsection{Librería MPAndroidChart}
%-------------------------------------------------------------------
\label{cap4:subsec:mpandroidchart}

MPAndroidChart es una librería que nos permite mostrar de forma fácil y personalizada grandes conjuntos de datos en formas gráficas \cite{mpandroidchart}. Permite además, arrastrar, escalados y animaciones en los gráficos, los cuales pueden ser de varios tipos, dependiendo de las necesidades y tipos de datos.
\\

Para realizar su integración con el proyecto Android, es necesario descargar la librería desde el repositorio oficial obteniendo un archivo \textit{.jar}. El mismo es añadido mediante la opción \textit{Add as Library} de Android Studio, y finalmente debe compilarse mediante su anotación en el \textit{build.gradle}.
\\

En relación al proyecto, dentro de la sección de estadísticas por encuesta brindada a los ``Usuario Específicos'', se preparan distintos gráficos para todas aquellas preguntas del tipo \textit{Múltiple Choice} o  \textit{Respuesta Única}, por ejemplo. De esta forma, nos permite conocer, analizar y comparar visual y rápidamente los distintos resultados obtenidos hasta el momento.

%------------------------------------------------------------------
\subsection{Librería OpenCsv}
%-------------------------------------------------------------------
\label{cap4:subsec:opencsv}

OpenCsv es una librería Java gratuita de parseos en CSV, tanto para lecturas como escrituras \cite{opencsv}. Los archivos CSV (comma-separated values) son un tipo de documento en formato abierto sencillo para representar datos en forma de tabla, en las cuales las columnas son separadas por comas (o punto y coma). 
\\

La librería ofrece principalmente las clases \textit{CSVReader} y \textit{CSVWriter}, las cuales dan operaciones para leer el fichero CSV como un arreglo de String o para escribir sobre uno de ellos, respectivamente. Tanto en la lectura como la escritura presentan las siguientes metodologías de parseo:

\begin{itemize}
	
	\item Desde y hacia un arreglo de Strings.
	
	\item Desde y hacia un Bean, mediante la clase \textit{CsvToBean} que realiza el parseo conforme a un \textit{MappingStrategy}, interfaz que define el mapeo entre los datos CSV y la clase Java.
	
	\item Desde una base de datos.
	
\end{itemize}

En este caso, gracias a las facilidades aportadas por OpenCsv, es posible llevar adelante la exportación de resultados para una determinada encuesta en el presente proyecto. Así como los ``Usuario Específicos'' pueden visualizar todas las estadíticas presentadas por cada encuesta, tienen disponible la opción de exportar resultados, la cual mediante la solicitud de un permiso extra para utilizar el almacenamiento interno del dispotivo móvil, guarda el archivo \textit{.csv} pudiendo ser accedido cuando se requiera. El mismo puede ser abierto con cualquier planilla de cálculos como por ejemplo Excel.

%-------------------------------------------------------------------
\section{Modelado de la aplicación}
%-------------------------------------------------------------------
\label{cap4:sec:modelado-aplicacion}

\newpage
\thispagestyle{empty}
\mbox{ }