%---------------------------------------------------------------------
%
%                          Capítulo 2
%
%---------------------------------------------------------------------

\chapter{Análisis y fundamentos teóricos}

\begin{resumen}
En este capítulo se presentará un análisis correspondiente a las bases teóricas del proyecto, teniendo en cuenta desde el punto de vista del Web Service, la aplicación Android y su relación con el diseño de solución propuesta. Los cuales son resultado de los requerimientos extraídos en función de la problemática detectada. 

A su vez, se llevará a cabo una presentación de las distintas tecnologías utilizadas, que servirá para comprender las decisiones de implementación que se tomaron, como por ejemplo el sistema operativo Android, el protocolo de transferencia HTTP, formatos de respuestas, etc.
\end{resumen}

%------------------------------------------------------------------
\section{Análisis del problema}
%-------------------------------------------------------------------
\label{cap2:sec:analisis-problema}

Según lo mencionado en el Capítulo 1 y en función del objetivo general del proyecto, se realizó un análisis del problema con la detección de los distintos requerimientos tanto funcionales como no funcionales, con la finalidad de poder elaborar una propuesta de acción en consecuencia.

%------------------------------------------------------------------
\subsection{Diagramas de casos de uso}
%-------------------------------------------------------------------
\label{cap2:subsec:diagramas-casouso}
Mediante el diagrama de casos de uso que se presenta a continuación (Figura \ref{fig:cu1} \& Figura \ref{fig:cu2}), se describe en forma gráfica la secuencia de operaciones que son llevadas a cabo por el sistema en respuesta a los eventos ejecutados por los distintos actores. Ésta técnica fue utilizada para la recolección de requerimientos funcionales de la aplicación.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/cu1}
		\caption{Diagrama de casos de uso 1}
		\label{fig:cu1}
	\end{center}
\end{figure}

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/cu2}
		\caption{Diagrama de casos de uso 2}
		\label{fig:cu2}
	\end{center}
\end{figure}


%------------------------------------------------------------------
\subsection{Definición de casos de uso}
%-------------------------------------------------------------------
\label{cap2:subsec:definicion-casouso}
Con la finalidad de mantener un correcto orden, en el Apéndice \ref{ap1:fichas-casosuso} se podrán encontrar las correspondientes fichas de los casos de uso, que se encargan de describir cada uno de ellos en forma particular (referenciando desde la Tabla \ref{tab:cu001} a la \ref{tab:cu025}).

%------------------------------------------------------------------
\subsection{Requerimientos funcionales}
%-------------------------------------------------------------------
\label{cap2:subsec:requerimientos-funcionales}

\begin{itemize}
	
	\item Para acceder a todas las funcionalidades de la aplicación los usuarios deben tener creada una cuenta.
	
	\item El sistema permitirá registrar una nueva cuenta o iniciar sesión, en la pantalla de logueo.
	
	\item Los usuarios ingresarán colocando nombre de usuario y contraseña.
	
	\item Los usuarios podrán registrase como ``específicos'' o ``comunes''. Para el primer caso, los mismos deben poseer un código de validación en la registración, para poder utilizar las funcionalidades de dicho tipo de usuario.
	
	\item El sistema ejecutará en primer y única instancia una validación para poder utilizar los recursos del dispositivo móvil.
	
	\item Una vez que se haya iniciado sesión, en la pantalla principal se encontrarán las encuestas disponibles de resolución y las funcionalidades de ABMs (en el caso de los usuarios específicos).
	
	\item El sistema presentará controles y validaciones a la hora de resolver libremente las encuestas.
	
	\item El sistema permitirá a los usuarios ``comunes'' resolver solamente una vez cada encuesta, si cumple las validaciones previas.
	
	\item El sistema permitirá la resolución indefinida de encuestas por parte de los usuarios específicos.
	
	\item El sistema permitirá a los usuarios específicos la realización de ABMs sobre las encuestas.
	
	\item Se llevará a cabo un histórico sobre las encuestas registrando fecha y usuario de creación, modificación o eliminación.
	
	\item Se podrá asociar un tipo de respuesta en cada pregunta (Ej. multiple choice, desarrollo libre, etc.).
	
	\item El sistema deberá ser capaz de geoposicionar al usuario utilizando los sensores móviles del dispositivo.
	
	\item El sistema brindará la posibilidad de introducir manualmente el posicionamiento de resolución de encuestas, si dicho usuario no se encuentra en su residencia habitual (para mejor información estadística en las respuestas).
	
	\item La aplicación brindará noticias e informaciones relacionadas a epidemiologías, salud, medicina, etc.
	
	\item Los usuarios específicos serán los encargados de los ABMs de la sección noticias e informaciones.
	
	\item La aplicación brindará estadísticas instantáneas sobre cada encuesta ya resuelta al menos una vez.
	
	\item En las encuestas geolocalizadas, dentro de las estadísticas se presentarán mapas estadísticos con la distribución de respuestas, verificando los alcances zonales.
	
	\item La aplicación debe estar sincronizada con el Web Service mediante datos móviles para el almacenamiento de los usuarios, las encuestas y las resoluciones de las mismas.
	
	\item El sistema enviará notificaciones de alerta cuando se lo desee (por Ej. para informar la disponibilidad de una nueva encuesta).
	
	\item Los datos recolectados de la resolución de encuestas podrán ser exportados en formato Excel para el uso posterior por parte de profesionales.
	
\end{itemize}

%------------------------------------------------------------------
\subsection{Requerimientos no funcionales}
%-------------------------------------------------------------------
\label{cap2:subsec:requerimientos-nofuncionales}

\begin{itemize}
	
	\item El dispositivo debe poseer sistema operativo Android con una versión mayor o igual a la 4.4 (KitKat).
	
	\item El dispositivo debe tener GPS, tenerlo activo y con una localización válida.
	
	\item El dispositivo debe poseer conexión a internet.
	
	\item El dispositivo debe contar con al menos 15MB libre de espacio para almacenamiento.
	
	\item El sistema debe presentar una interfaz de uso intuitiva y sencilla.
	
	\item El sistema debe ser capaz de procesar las transacciones en segundos.
	
	\item El sistema debe ser capaz de actuar con varios usuarios concurrentes.
	
	\item Los almacenamientos en base de datos deben ser transaccionales para mantener la integridad de los datos.
	
	\item El sistema debe presentar mensajes informativos y orientados al usuario final.
	
	\item Las encuestas modificadas deben actualizarse instantáneamente en la base de datos para que todos los usuarios posean la versión correcta.
	
\end{itemize}

%------------------------------------------------------------------
\section{Elecciones de implementación}
%-------------------------------------------------------------------
\label{cap2:sec:elecciones-implementacion}

Una vez definidos todos los requerimientos que harán frente a la problemática mencionada, a continuación se mencionarán las decisiones de implementación que se tomaron en relación a los lenguajes de programación y herramientas utilizadas, para poder llevar a cabo los mismos cumpliendo la propuesta de solución adecuadamente.
\\

En lo que corresponde al desarrollo del proyecto, se decidió desde un comienzo separar al mismo en dos grandes módulos: el Web Service y la aplicación móvil Android. Como la temática principal está centrada sobre los datos de almacenamiento, tanto para el manejo de usuarios como para las encuestas y resoluciones en general, se consideró llevar a cabo el diseño y desarrollo de un Web Service que tendrá como funcionalidad montarse por encima de la base de datos y permitir acceder a ella, plasmando toda la lógica de negocio allí.
\\

Por parte de la aplicación Android, en éste tipo de proyecto no es posible montar una base de datos interna, es decir utilizando la memoria RAM del dispositivo, ya que los datos están fuertemente ligados a la interacción de los usuarios. Es necesario de disponer un servidor central para el almacenamiento de usuarios y login por ejemplo, pero principalmente para el manejo de encuestas y resultados, ya que las mismas poseen un carácter dinámico partiendo de la creación de un determinado usuario para luego ser distribuidas y resueltas por el resto de la comunidad. 
\\

Al poseer la lógica de negocios dentro del Web Service, la aplicación deberá consumir los servicios que el mismo expone para llevar adelante todas las funcionalidades establecidas, es por ello que sólo puede ser llevado a cabo por dispositivos que poseen acceso a Internet. De esta forma, la app queda abstraída de toda la lógica, haciendo que el día de mañana al querer realizar cambios sobre los mismos no sea necesario re-lanzar una nueva versión, la cual luego debería ser actualizada individualmente por cada usuario que la tenga instalada.

%------------------------------------------------------------------
\subsection{Lenguaje de programación}
%-------------------------------------------------------------------
\label{cap2:subsec:lenguaje-programacion}

Para llevar adelante el desarrollo de la aplicación móvil se escogió el lenguaje de programación Java. Es muy conocido en el ambiente de programación Android, por ser un lenguaje que tiene una comunidad bastante grande y sobre todo una comunidad con bastante experiencia en el desarrollo de software. Java juega un papel muy importante, principalmente en el soporte ante casi cualquier eventualidad presentada.
\\

En los últimos años apareció el lenguaje de programación Kotlin, el cual fue adoptado por Google como lenguaje oficial de desarrollo Android. Para los fines prácticos del proyecto, los resultados podrían ser alcanzados utilizando tanto Java como Kotlin. Sin embargo, éste último al poseer pocos años dentro del mercado, la cantidad de información disponible en la web es muy escasa, haciendo que a la hora de escoger entre los mencionados la decisión se incline por Java.
\\

En cuanto al desarrollo del Web Service, la distribución de posibilidades a la hora de elegir un lenguaje de programación es más variada en relación a la aplicación móvil. Para partir de un análisis, inicialmente se priorizó aquellos lenguajes compilados por sobre los interpretados, por poseer mayor velocidad de ejecución e implementaciones más robustas; y aquellos lenguajes orientados a objetos, ya que son más sencillos de mantener y se posee mayor fiabilidad al dividir el problema en pequeñas partes, pudiendo ser probadas de manera independiente.
\\

Analizando la propuesta de solución establecida anteriormente, donde la aplicación móvil tiene como finalidad consumir los servicios de un Web Service y éste a su vez mantiene las conexiones pertinentes con la base de datos, el modelo correcto a implementar es del estilo MVC (Modelo Vista Controlador). En el controlador se presentarán todos los \textit{endpoints} que serán accedidos por la aplicación mediante peticiones HTTP, los cuáles a su vez están relacionados con los servicios y modelos de datos.
\\

Para llevar adelante el modelo establecido, mediante investigaciones previas y por experiencia personal del ejecutor del proyecto en trabajos anteriores, se determinó que mediante la integración de los frameworks Spring y Hibernate, es posible cubrir todo el ciclo de vida del modelo MVC (en capítulos posteriores se brindarán más detalles de dichas elecciones). Dentro de los lenguajes compilados y orientados a objetos, dichos frameworks son compatibles tanto para Java como .NET. En la actualidad, ambos lenguajes son altamente utilizados en el mercado para el desarrollo de aplicaciones web backend, por lo cual el soporte y la documentación no serían un inconveniente.
\\

Se estableció que la implementación del Web Service sea llevada adelante bajo el lenguaje de programación Java. Más allá de la experiencia del desarrollador del proyecto utilizando el mismo, lo cuál permite no consumir tiempo extra en el aprendizaje de una nueva tecnología, se determinó que posee mayor portabilidad. Es decir, Java puede ser utilizado desde varios entornos de desarrollo integrado (IDE), cualquier sistema operativo y puede ser compilado por cualquier contenedor de servlets. En este caso .NET cuenta solamente con el IDE Visual Studio como oficial, el cuál puede ser ejecutado únicamente en plataformas con sistema operativo Windows de forma nativa, haciendo que ciertas funcionalidades no se encuentren disponibles en forma gratuita. 
\\

Por lo tanto, la máquina virtual de Java (JVM) se sitúa en un nivel superior al hardware del sistema sobre el que se pretende ejecutar la aplicación, y éste actúa como puente que entiende tanto el bytecode (programa Java compilado) como el sistema sobre el que se pretende ejecutar (Figura \ref{fig:jvm}). Entonces, cuando se escribe una aplicación Java se hace pensando que será ejecutada en una máquina virtual Java en concreto, siendo ésta la que en última instancia convierte de código bytecode a código nativo del dispositivo final, es decir pudiendo ser interpretado por cualquier sistema operativo \cite{javaLibro}.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/jvm}
		\caption{Máquina virtual Java - JVM}
		\label{fig:jvm}
	\end{center}
\end{figure}

%------------------------------------------------------------------
\subsection{Lenguajes compilados}
%-------------------------------------------------------------------
\label{cap2:subsec:lenguajes-compilados}

Como se especificó previamente, para llevar adelante el desarrollo del Web Service se optó por la utilización de un lenguaje compilado por sobre uno interpretado. Los lenguajes de programación compilados son aquellos cuyo código fuente, escrito en un lenguaje de alto nivel, es traducido por un compilador a un archivo ejecutable entendible para la máquina en determinada plataforma. Con ese archivo se puede ejecutar el programa cuantas veces sea necesario sin tener que repetir el proceso por lo que el tiempo de espera entre ejecución y ejecución es ínfimo.
\\

Se marca una diferencia por sobre los lenguajes interpretados, ya que éstos últimos ejecutan paso a paso el código fuente sin llevar a cabo ninguna traducción en la pre-ejecución. Ésto hace que se genere luego una sobrecarga en el proceso de traducción reduciendo la velocidad en tiempo de ejecución.

%------------------------------------------------------------------
\subsection{Programación orientada a objetos}
%-------------------------------------------------------------------
\label{cap2:subsec:orientado-objetos}

La programación orientada a objetos (POO) es un paradigma de programación que se basa en subdividir el problema principal en distintos actores o entidades individuales (objetos), denominados \textit{clases}, donde cada uno posee atributos, funcionalidades particulares e interactúan con los demás. Al instanciar una clase se obtiene un caso particular de la misma, es decir un objeto, el cual puede tener atributos distintos a otras instancias de la misma.
\\

Cada objeto posee particularmente estado (atributos), comportamiento (métodos) e identidad. La identidad es una propiedad de un objeto que lo diferencia del resto, dicho con otras palabras, es su identificador. Contiene toda la información que permite definirlo e identificarlo frente a otros objetos pertenecientes a otras clases e incluso frente a objetos de una misma clase, al poder tener valores bien diferenciados en sus atributos. A su vez, los objetos disponen de mecanismos de interacción llamados métodos, que favorecen la comunicación entre ellos. Esta comunicación favorece a su vez el cambio de estado en los propios objetos. Esta característica lleva a tratarlos como unidades indivisibles, en las que no se separa el estado y el comportamiento.
\\

Los métodos (comportamiento) y atributos (estado) están estrechamente relacionados por la propiedad de conjunto. Esta propiedad destaca que una clase requiere de métodos para poder tratar los atributos con los que cuenta.
\\

Dentro de las ventajas que posee la programación orientada a objetos, se puede obtener una buena abstracción del problema en clases, objetos y atributos, brindando una implementación más detallada, puntual y coherente \cite{poo}. Además permite una mejor reutilización de código, modificabilidad, encapsulamiento y fiabilidad, entre otras cosas.
\\

Como ya se ha especificado anteriormente Java se trata de un lenguaje de programación que soporta éste paradigma. En unidades posteriores se verá con mayor detalle como el problema principal fue abstraído, adaptándose al modelo de objetos y llevando adelante dicho mecanismo.

%------------------------------------------------------------------
\section{Conceptos del lado del servidor}
%-------------------------------------------------------------------
\label{cap2:sec:conceptos-servidor}

Tal como se especificó anteriormente, desde la aplicación será necesaria la conexión a Internet para lograr el acceso a la base de datos. La propuesta de solución corresponde a una arquitectura cliente-servidor de 3 capas, la cuál se verá con más detalles en el capítulo posterior.
\\

La metodología de trabajo que posee ésta arquitectura, es un cliente realizando peticiones (mediante el dispositivo móvil) hacia un servidor (Web Service) que se encargará de enviar las respuestas (Figura \ref{fig:cliente-servidor}). Dichas peticiones serán bajo el protocolo \textit{HTTP} y el formato de respuestas \textit{JSON}, los cuales serán ampliados en el presente capítulo.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/cliente_servidor}
		\caption{Cliente - Servidor}
		\label{fig:cliente-servidor}
	\end{center}
\end{figure}

%------------------------------------------------------------------
\subsection{Arquitectura}
%-------------------------------------------------------------------
\label{cap2:subsec:arquitectura-ws}

Como se mencionó anteriormente, el servidor se encontrará desplegado en el Web Service. Dicho Web Service es un conjunto de protocolos y estándares que sirven para intercambiar datos entre aplicaciones. Éstas aplicaciones pueden estar desarrolladas en diferentes lenguajes de programación y siendo ejecutadas bajo cualquier plataforma de manera indiferente \cite{webServiceLibro}.
\\

Dentro de las ventajas que abarca la utilización de un Web Service, se mencionan las siguientes:
\begin{itemize}
	
	\item Aportan interoperabilidad entre aplicaciones de software independientemente de sus propiedades o de las plataformas sobre las que se instalen.
	
	\item Brindan abstracción, siendo totalmente independiente de la base de datos y el cliente, por lo que un cambio en la lógica de negocios no afectaría a ninguno de ellos.
	
	\item Fomentan los estándares y protocolos basados en texto, que hacen más fácil acceder a su contenido y entender su funcionamiento.
	
	\item Al apoyarse en HTTP, los Web Service pueden aprovecharse de los sistemas de seguridad firewall sin necesidad de cambiar las reglas de filtrado.
	
\end{itemize}	

Para su creación, es fundamental definir qué tipo de arquitectura será la más apropiada para la propuesta de solución. Dentro de las disyuntivas, tenemos los siguientes tipos:

\begin{itemize}
	
	\item \textbf{\textit{SOAP}} (Simple Object Access Protocol): éste protocolo estándar define como dos objetos en diferentes procesos pueden comunicarse por medio de intercambios de datos XML (Extensible Markup Language). Los servicios SOAP funcionan por lo general bajo el protocolo HTTP (más común), aunque no está limitado solamente a éste, pudiendo trabajar con protocolos FTP, POP3, TCP, entre otros. SOAP es una arquitectura muy robusta y con gran seguridad, pero a su vez bastante pesada, tanto en tamaño como en procesamiento.
	
	\item \textbf{\textit{REST}} (Representational State Transfer): ésta arquitectura es más nueva en relación a la anterior. Se puede mencionar que la misma es mucho más flexible y transporta datos mediante el protocolo HTTP, pudiendo utilizar los distintos métodos que proporciona el mismo  para la comunicación como el GET, POST, PUT, etc. Gracias a su flexibilidad permite transportar cualquier tipo de datos, como pueden ser XML, JSON (JavaScript Object Notation), binarios, etc.
	
\end{itemize}

Por lo tanto, se estableció que el tipo de Web Service a implementar sea bajo la arquitectura REST, ya que se adapta a las necesidades del proyecto, es más sencillo y rápido de implementar.
\\

Como se mencionó, SOAP solamente permite el formato XML lo cual lo hace más pesado en relación a REST, donde en éste último se pueden enviar los datos mediante JSON (JavaScript Object Notation) por ejemplo. Brindando de ésta forma una mayor flexibilidad y mejor performance, ya que éstos tipos de datos son mucho más livianos en peso y más rápidos para su procesamiento por no requerir de etiquetas como en XML, además de poseer mayor soporte y ser de más fácil lectura.
\\

Una de las ventajas que posee el protocolo SOAP es su mayor seguridad para el transporte de datos, lo cual puede ser subsanado en gran parte por la arquitectura REST, mediante el protocolo de transferencia HTTPS (Protocolo seguro de transferencia de hipertexto). Como ya se mencionó anteriormente, al estar basados en este protocolo, se pueden utilizar los distintos métodos que proporciona para  el intercambio de datos, como por ejemplo, las peticiones GET realizando consultas al servidor y enviando las respuestas por el mismo canal, peticiones POST para almacenamientos, PUT para actualizaciones, entre otras, que van a ser de gran utilidad a lo largo del  proyecto. Cada mensaje HTTP contiene toda la información necesaria para ejecutar la petición por lo tanto no se requiere guardar ningún tipo de estado de la comunicación sino que todas son independientes entre sí.
\\

Sin tener que depender de una definición WSDL (Web Services Description Language), los WS REST proveen una sintaxis universal de modo tal que cada recurso que posee se pueda direccionar de forma unívoca a través de la URI, el cual es una combinación entre la URL y la URN (Uniform Resource Name), que identifica el nombre del recurso en la red en cuestión.

%------------------------------------------------------------------
\subsection{Protocolo HTTP}
%-------------------------------------------------------------------
\label{cap2:subsec:protocolo-HTTP}
El Protocolo de Transferencia de Hipertexto (HTTP), es el protocolo de comunicación que permite las transferencias de información en la World Wide Web. Es un protocolo del tipo cliente-servidor, lo que significa que el cliente envía una petición al servidor y espera un mensaje de respuesta del mismo, a través de una conexión TCP (Transmission Control Protocol). Es un protocolo sin estado, lo que significa que el servidor no guarda información del cliente, cada petición es independiente de las demás \cite{httpProtocolo}.
\\

Un mensaje HTTP, sin importar si es una petición o una respuesta, está compuesto por tres partes (Figura \ref{fig:http-messages}):
\begin{itemize}
	
	\item La primera línea (en éste caso varía para una petición o una respuesta).
	
	\item Los encabezados.
	
	\item El cuerpo.
	
\end{itemize}

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/http-messages}
		\caption{Mensajes HTTP}
		\label{fig:http-messages}
	\end{center}
\end{figure}

En el caso de la primera línea en las peticiones está compuesto por el verbo, el recurso a consumir y la versión de HTTP. Mientras que en las respuestas se encuentran la versión de HTTP y el código de respuesta.
\\

Los verbos, también conocidos como métodos, son aquellos que definen la acción que se desea realizar sobre el recurso identificado. Hay un total de 8 métodos, de los cuáles será necesario utilizar 4 de ellos para llevar a cabo la propuesta de solución:

\begin{itemize}
	
	\item \textbf{GET}: se utiliza para solicitar un recurso (traer datos de BD).
	
	\item \textbf{POST}: se utiliza para publicar un recurso (dar de alta en BD).
	
	\item \textbf{PUT}: se utiliza para reemplazar un recurso (modificar datos en BD).
	
	\item \textbf{DELETE}: se utiliza para eliminar un recurso (dar de baja en BD).
	
\end{itemize}

Una vez ejecutada una petición, el servidor se encargará de enviar una respuesta, la cuál contendrá un código de estado y el tipo de dato MIME de la información de retorno, seguido de la propia información. Los códigos de estado le indican al cliente como interpretar la respuesta, teniendo en cuenta su categoría dependiendo del dígito con el que comienzan:

\begin{itemize}
	
	\item 1xx: Información.

	\item 2xx: Éxito.
	
	\item 3xx: Redirección.
	
	\item 4xx: Error en el cliente.
	
	\item 5xx: Error en el servidor.
	
\end{itemize}

Las peticiones son enviadas mediante URLs (Uniform Resource Locator), las cuales se encargan de ubicar un recurso en Internet. Como se puede ver en el ejemplo de URL en la Figura \ref{fig:http-url}, la misma se compone por la siguiente información:

\begin{itemize}
	
	\item \textit{Esquema}: define el protocolo a utilizar, el cual puede ser http o https (protocolo seguro de HTTP).
	
	\item \textit{Host}: La IP o el nombre del servidor que se quiere acceder. Para un entorno de prueba local el host será \textit{localhost}, aunque también podría ser la dirección de IP privada dentro de la red donde se está trabajando, y en el caso de una puesta en producción en Internet del Web Service, será la dirección de IP pública para ese host.
	
	\item \textit{Puerto}: el puerto en el que está escuchando el servidor HTTP. Si se omite se asume que es el 80. En el caso del proyecto el puerto será el 8080, utilizado por el contenedor de Servlets para el acceso al Web Service.
	
	\item \textit{Path}: la ruta al recurso que se quiere acceder. En el caso del proyecto será el nombre de los servicios que se desarrollaron en el Web Service.
	
	\item \textit{Query String}: Contiene información adicional para el servidor en forma de propiedades (atributo=valor). Las propiedades se separan por \&.
	
\end{itemize}

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/http-url}
		\caption{URL HTTP}
		\label{fig:http-url}
	\end{center}
\end{figure}

En el caso de peticiones con métodos POST y PUT, gran parte de la información a almacenar será enviada en el cuerpo del mensaje y no como parámetros, con la finalidad de tener URLs más legibles y no ser extremadamente largas, además de seguir las buenas prácticas de programación.

%------------------------------------------------------------------
\subsection{Formato de respuestas}
%-------------------------------------------------------------------
\label{cap2:subsec:formato-respuestas}

Como se mencionó anteriormente cuando el cliente realiza una petición hacia el servidor, éste se encarga de enviar una respuesta al mismo. Hay servicios en los cuáles simplemente se puede responder un código de estado, otorgándole de ésta manera información suficiente al cliente sobre la transacción realizada. Por ejemplo, confirmando el éxito de un ABM realizado. 
\\

A su vez, existe gran cantidad de situaciones en las cuáles es necesario enviar más información en la respuesta. Por lo tanto, es necesario determinar que formato tendrá dicha respuesta, logrando que ésta sea homogénea de forma que el cliente sepa anticipadamente como decodificar la misma.
\\

Tal como se explicó previamente, de acuerdo al tipo de arquitectura escogida para el Web Service, la respuesta se podía formatear como JSON o XML. Dentro de la arquitectura REST, se escogió el formato JSON que tiene como ventajas poseer mayor soporte, un formato sumamente simple, mayor velocidad de procesamiento y menor tamaño en los archivos. En tanto el formato XML, requiere el uso de etiquetas lo cual lleva a un formato más estricto y mayor uso de ancho de banda, haciendo que el tiempo de procesamiento sea mayor.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/json_xml}
		\caption{XML vs. JSON}
		\label{fig:xml-json}
	\end{center}
\end{figure}

En cuanto a la sintaxis de los JSON, los mismos están constituidos por una colección de pares nombre/valor. Los tipos de datos disponibles en éstos valores son los siguientes:

\begin{itemize}
	
	\item \textit{Números}: se permiten números negativos y opcionalmente pueden contener parte fraccional separada por puntos.
	
	\item \textit{Cadenas}: secuencias de cero o más caracteres. Se ponen entre doble comilla y se permiten cadenas de escape.
	
	\item \textit{Booleanos}: true o false.
	
	\item \textit{Null}: representan el valor nulo.
	
	\item \textit{Array}: lista ordenada de cero o más valores los cuales pueden ser de cualquier tipo. Los valores se separan por comas y el vector se mete entre corchetes.
	
	\item \textit{Objetos}: colecciones no ordenadas de cero o más pares \{nombre: valor\} separados por comas y puestas entre llaves. El nombre tiene que ser una cadena y el valor puede ser de cualquier tipo.
	
\end{itemize}

%------------------------------------------------------------------
\subsection{Servlet}
%-------------------------------------------------------------------
\label{cap2:subsec:servlet}

Los Servlets son módulos Java que se utilizan en un servidor, para extender sus capacidades de respuesta a los clientes al utilizar las potencialidades de Java. Son para los servidores lo que los \textit{applets}\footnote{Pequeños programas que se ejecutan en el contexto de un navegador web} para los navegadores, aunque los servlets no tienen una interfaz gráfica.
\\

Esto quiere decir, que nos permite construir aplicaciones web que admiten peticiones a través del protocolo HTTP accediendo a ellos mediante un navegador web. La respuesta generalmente es enviada en formato HTML y representada por dicho navegador.
\\

Los Servlets son un reemplazo efectivo para los CGI en los servidores que los soporten ya que proporcionan una forma de generar documentos dinámicos utilizando las ventajas de la programación en Java como conexión a alguna base de datos, manejo de peticiones concurrentes, programación distribuida, etc. Por ejemplo, un servlet podría ser responsable de procesar los datos desde un formulario en HTML como registrar la transacción, actualizar una base de datos, contactar algún sistema remoto y retornar un documento dinámico o redirigir a otro servlet u alguna otra cosa.
\\

Un contenedor Servlet es un programa capaz de recibir peticiones de páginas web y redireccionar las mismas a un objeto Servlet, esto quiere decir también que podemos tener corriendo varias aplicaciones bajo un mismo contenedor (un mismo servidor). El Web Service desarrollado en el proyecto es un Servlet en particular, que está corriendo en un contenedor. Dicho contenedor, escogido para funcionar como servidor web por sí mismo es el Apache Tomcat. Éste se encuentra desarrollado en Java, por lo tanto es compatible con cualquier sistema operativo que soporte el JVM.
\\

Para acceder a una aplicación en particular, se realizará mediante la URL, como ya fue mencionado previamente. Dichas peticiones pueden ser enviadas desde cualquier browser, siempre y cuando se trate de métodos GET, caso contrario se puede utilizar cualquier aplicación encargada de enviar peticiones HTTP, como por ejemplo \textit{Postman}. Luego Tomcat se encarga de direccionar las peticiones de Servlet que llegan al puerto establecido por defecto (8080).
\\

Al realizar una petición HTTP, el contenedor de Servlets delega la misma a un Servlet en particular entre los que contiene. Éste se encarga de generar la respuesta para luego entregarla al contenedor, donde éste finalmente devuelve la misma al cliente en el formato adecuado (Figura \ref{fig:servlet}).

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/servlet}
		\caption{Peticiones y manejo de Servlet}
		\label{fig:servlet}
	\end{center}
\end{figure}

\newpage
\thispagestyle{empty}
\mbox{ }