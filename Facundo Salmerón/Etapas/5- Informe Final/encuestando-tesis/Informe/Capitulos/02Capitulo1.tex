%---------------------------------------------------------------------
%
%                          Capítulo 3
%
%---------------------------------------------------------------------
\lstset{
	escapeinside={<@}{@>},
	frame = single, 
	language=Java}
\definecolor{mygray}{RGB}{118, 118, 118}
\definecolor{myblue}{RGB}{27, 6, 215}
\definecolor{mypurple}{RGB}{128, 75, 119}
\def\graycolor{\color{mygray}}
\def\blackcolor{\color{black}}
\def\bluecolor{\color{myblue}}
\def\purplecolor{\color{mypurple}}

\chapter{Diseño y desarrollo del servidor}

\begin{resumen}
En este capítulo se describen todos los aspectos relacionados al diseño y desarrollo tanto de la base de datos como del Web Service, junto a los distintos modelados y diagramas. Se presentará la arquitectura escogida de resolución.
\\
Además, se ampliará la información relativa a los frameworks utilizados en el desarrollo y su relación con las distintas capas de arquitectura.
\\
Finalmente, se presentarán todos los servicios (endpoints) que estarán disponibles en el Web Service, para luego ser consumidos por la aplicación móvil.
\end{resumen}

%-------------------------------------------------------------------
\section{Base de datos}
%-------------------------------------------------------------------
\label{cap4:sec:implementacion-db}

En base a lo expuesto en secciones anteriores, es necesario el uso de un sistema de almacenamiento para poder manejar toda la información con la que la aplicación va a trabajar. Los datos a guardar serán relacionados a los usuarios que van a interactuar con el sistema y las encuestas en sí. Los mismos serán creados y accedidos por el Web Service.
\\

En esta sección se presentará todo lo relacionado al gestor de base de datos escogido, junto al diseño del mismo.

%------------------------------------------------------------------
\subsection{Gestor de la base de datos}
%-------------------------------------------------------------------
\label{cap2:subsec:gestor-db}

Para llevar adelante la gestión de la base de datos se escogió \textit{MySQL}. Es un gestor de bases de datos relacional, considerado como la base de código abierto más popular en el mundo \cite{mysqlPopular} y la segunda más popular a nivel general, detrás de la licencia propietaria de \textit{Oracle} \cite{mysqlRanking}, sobre todo para entornos de desarrollo web.
\\

MySQL posee un esquema de doble licenciamiento, donde la base de datos se distribuye en varias versiones, una \textit{Community} distribuida bajo la licencia pública general de GNU\footnote{https://www.gnu.org/home.es.html} y varias versiones \textit{Enterprise}, para aquellas empresas que quieran incorporarlo en productos privativos.
\\

Se posee gran cantidad de documentación, lo cual es de gran ayuda para resolver cualquier inconveniente que se presente. Este gestor brinda la posibilidad de desarrollar una base de datos de tipo \textit{OLTP} (On Line Transaction Processing), también llamadas bases de datos dinámicas, la cual es acorde al proyecto, ya que permite que la información sea modificada en tiempo real, pudiendo insertar, eliminar, modificar o consultar datos durante la operación del sistema, a diferencia de las bases de datos de tipo \textit{OLAP} (On Line Analytcal Processing) que son estáticas, es decir no se insertan, eliminan, ni modifican datos, sino que solamente se pueden realizar consultas sobre datos ya existentes \cite{tiposDB}.
\\

Dentro de las ventajas a mencionar en cuanto a la elección de este gestor por sobre SQLServer u Oracle por ejemplo (dos de los gestores de base de datos más populares), MySQL es un software totalmente open source a diferencia de los mencionados y posee gran velocidad a la hora de realizar operaciones (siendo uno de los mejores rendimientos), posee bajos costos en los requerimientos para la elaboración de la base de datos, pudiendo ejecutarse en máquinas de escasos recursos gracias a su bajo consumo y existen diversos drivers para efectuar conexiones a la misma. Pero sin dudas, una de las mayores ventajas se debe a que por su conectividad, velocidad y seguridad es altamente apropiada para acceder a bases de datos a través de Internet como lo será en este proyecto.
\\

En este proyecto se trabajó con la versión Community, en los sistemas operativos Windows 10 y Ubuntu 18.04 LTS, aprovechando esta ventaja multiplataforma que posee MySQL. Además, se utilizó \textit{MySQL Workbench}, una herramienta opcional dentro de la versión Community, con la cual se brinda un entorno visual que permite el diseño de la base de datos, administración y ejecución de consultas.

%------------------------------------------------------------------
\subsection{Modelado del problema}
%-------------------------------------------------------------------
\label{cap2:subsec:modelado-db}

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=1\textwidth]%
		{Imagenes/Bitmap/modelo_db}
		\caption{Diseño de la base de datos}
		\label{fig:modelobd}
	\end{center}
\end{figure}

Una vez definido e instalado el gestor de base de datos escogido, se prosiguió por diseñar el modelo del problema, en donde se desglosa el problema principal en distintas entidades las cuales van a ser representadas por tablas y poseen relaciones entre ellas. El diagrama de tablas de la base de datos se presenta en la Figura \ref{fig:modelobd}.
\\

Al tratarse de una base de datos del tipo relacional, se puede notar que todas las tablas poseen un \textit{ID} el cual realiza las tareas de clave primaria o primary key (PK)\footnote{Representadas en el diagrama por una llave amarilla.}. Su funcionalidad es la de identificar en forma única a cada fila de una tabla, por lo que cuenta con el carácter de unicidad. La tabla \textit{Resultado\_Respuesta} es la única que no posee un ID propio, ya que simplemente representa la relación entre dos entidades.
\\

Entrando más en detalle del modelo presentado, inicialmente es conveniente realizar una descripción del manejo de usuarios. Para ello se presentan tres tablas \textit{Sexo}, \textit{Tipo\_Usuario} y \textit{Usuario}. La primera resulta de carácter intuitivo, donde simplemente se describe el género de las personas. En la segunda tabla se representa el tipo de usuario que puede adquirir una persona, donde inicialmente se establecieron ``Usuarios Específicos'' y ``Usuarios Comunes'', dejando abierta la posibilidad de introducir un nuevo rol en un futuro. En cuanto a la tercer entidad, almacena todos los datos de los usuarios que van a interactuar con la aplicación. Más allá de poseer un ID como se especificó anteriormente, tiene además otros datos con carácter de unicidad como el DNI, nombre de usuario y mail para mayor seguridad y control de los registros establecidos \footnote{Aquellos datos \textit{not null} se representan en el diagrama mediante un diamante celeste, mientras que los \textit{nullables} se representan mediante un diamante blanco.}. 
\\

Como se puede ver, esta tabla se relaciona con las dos primeras, es decir cada usuario tiene un género y un tipo. Así es como posee dos claves foráneas o foreign key (FK)\footnote{Representadas en el diagrama por un diamante rosa.}, es decir una columna de la tabla que se corresponde exactamente con una columna de otra tabla donde está definida como PK para establecer la relación.
\\

Para el modelado de las encuestas que se van a llevar a cabo, se presenta la tabla denominada \textit{Encuesta}. Dentro de los atributos que posee, cabe destacar la diferencia entre ``Activa'' y ``Habilitada''. Al producirse el alta de una de ellas, la misma queda en estado activa (true), pero no estará disponible para ser resuelta por los usuarios hasta que se encuentre habilitada. Además, se llevará a cabo una auditoria de las mismas, registrando qué usuario y en qué fecha realizó algún ABM. Cabe destacar que las eliminaciones o bajas serán del tipo lógico (poniéndolas como activo = false), con la finalidad de no perder los registros y respaldar la auditoría propiamente dicha.
\\

A su vez, la tabla de encuestas se encuentra relacionada con la entidad \textit{Pregunta}, donde se van a almacenar todas aquellas que formen parte del formulario. Es por ello que la presente tabla contiene una FK contra las encuestas y otra con la entidad \textit{Tipo\_Pregunta}. Esta última determina de qué carácter es la pregunta en relación a su respuesta, es decir si se trata de una ``Múltiple Choice'', ``Respuesta Única'', ``Desarrollo'', etc. Por lo tanto, cada pregunta va a poseer una o más respuestas dependiendo del tipo. Esta última entidad se representa en la tabla \textit{Respuesta}.
\\

A la hora de responder las encuestas, los datos obtenidos serán almacenados en la tabla \textit{Resultado}. Presenta una FK con la entidad Usuario, para determinar quién fue el encargado de la resolución. Si se trata de un usuario común, los atributos edad y sexo serán completados automáticamente por dicha relación, mientras que si se trata de un usuario específico, los datos serán introducidos manualmente a la hora de resolver una determinada encuesta. En cuando al campo ``Descripción respuesta'', se almacenará el texto respondido, si se tratara de preguntas que no poseen respuestas predefinidas como las múltiple choice, por ejemplo.
\\

Es por ello que las tablas de resultados y respuestas se encuentran relacionadas. Al tratarse de una relación ``Muchos a muchos'' o ``Many to Many'', es decir un resultado puede tener N respuestas y una respuesta estar en M resultados, la relación se almacenará en la tabla \textit{Resultado\_Respuesta}. Dicha entidad contiene solamente un PK compuesto\footnote{Representado en el diagrama mediante una llave roja.}, es decir las FK correspondientes a las dos tablas relacionadas.
\\

Por último, se encuentra aislada la tabla \textit{Informacion\_Noticia} en la que se almacenarán todas aquellas noticias e informaciones que se consideren de interés para el resto de los usuarios. Como atributos presentará un título y una descripción (esta última opcional) y una URL que hará referencia al sitio donde se aloja la noticia en sí.
\\

Cabe aclarar que una vez creadas las tablas en la base de datos, se realizó una carga inicial mediante sentencias SQL sobre las entidades Sexo, Tipo de Usuario y Tipo de Preguntas, ya que son datos predefinidos independientes de la aplicación móvil. El resto de las tablas se irán poblando mediante los consumos que realice la app sobre Web Service.

%-------------------------------------------------------------------
\section{Web Service}
%-------------------------------------------------------------------
\label{cap4:sec:implementacion-ws}

Una vez definida e implementada la base de datos, en la presente sección se detallarán todos los aspectos relacionados al desarrollo del Web Service. Se incluye una descripción del proyecto Java, el modelado de objetos junto a los diagramas de clase, la arquitectura escogida para la resolución, frameworks utilizados y demás conceptos relacionados.

%------------------------------------------------------------------
\subsection{Proyecto Maven}
%-------------------------------------------------------------------
\label{cap2:subsec:maven}

A la hora de crear el proyecto Java encargado de realizar las funciones de Web Service, se desarrolló el mismo bajo un proyecto del tipo \textit{Maven}. Maven es una herramienta de software para la gestión y construcción de proyectos Java, desarrollada y mantenida por Apache Software Foundation\footnote{https://www.apache.org/} al igual que Tomcat (el contenedor de servlets escogido mencionado anteriormente).
\\

Tiene un modelo de configuración de construcción basado en un archivo con formato XML. Se trata del \textit{Project Object Model} (POM) que se encarga de describir el proyecto de software a construir, sus dependencias de otros módulos y componentes externos (como por ejemplo la utilización de librerías y frameworks), y el orden de construcción de los elementos.
\\

Una de las principales características que posee Maven es su capacidad de trabajar en red. El motor incluido en su núcleo puede dinámicamente descargar plugins de un repositorio (Maven Central), el mismo repositorio que provee acceso a muchas versiones de diferentes proyectos Open Source en Java, de Apache y otras organizaciones y desarrolladores \cite{maven1}\cite{maven2}.
\\

Mediante las anotaciones realizadas en el POM, Maven automáticamente detecta los cambios y realizan descargas dinámicas de los repositorios, permitiendo no tener que instalar manualmente cada dependencia a utilizar. Como se puede ver en la Figura \ref{fig:estructura-maven}, la cual posee una estructura básica de estos tipos de proyectos, los JAR (Java Archive) se presentan dentro del paquete \textit{Maven Dependencies}, además de ser descargados en una carpeta local oculta.
\\

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/estructura_maven}
		\caption{Estructura de proyecto Maven}
		\label{fig:estructura-maven}
	\end{center}
\end{figure}

En el proyecto, esta herramienta sirvió de gran utilidad a la hora de descargar e instalar dependencias externas como frameworks o librerías. Permitió automatizar tareas que desde el punto de vista del desarrollador pueden llegar a demandar mayor tiempo y resultar tediosas. En la figura \ref{fig:maven-pom} se presenta un ejemplo de anotación incluido en el pom.xml para la descarga de un framework.
\\ 

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/anotacion_pom}
		\caption{Dependencia en pom.xml}
		\label{fig:maven-pom}
	\end{center}
\end{figure}

Dentro de las dependencias utilizadas para el desarrollo del Web Service se destacan las siguientes (las dos primeras serán explicadas con mayor detalle posteriormente):

\begin{itemize}
	
	\item Spring Framework.
	
	\item Hibernate.
	
	\item Apache Commons DBCP: permite la interacción con una base de datos relacional, por ejemplo creando conexiones para los usuarios, realizando transacciones, etc.
	
	\item Log4J: permite a la aplicación mostrar mensajes de información de lo que está sucediendo en ella, lo que habitualmente se conoce como log.
	
	\item Servlet: distribución de contenedores servlet como por ejemplo Tomcat, ya descriptos anteriormente.
	
	\item JUnit: conjunto de bibliotecas que facilitan la realización de pruebas unitarias dentro del proyecto Java.
	
	\item Gson: biblioteca que permite la serialización y deserialización entre objetos Java y su representación en notación Json.
	
	\item Json: librería para la creación de objetos Json.
	
	\item MySQL Connector: librería que permite conectar nuestro código Java con la base de datos MySQL, de forma que se puedan realizar consultas a la misma.
	
	\item Apache Commons: conjunto de proyectos de Apache Software Foundation que provee componentes de software Java reutilizables. Por ejemplo la codificación de contraseñas bajo la encriptación en Base 64.
	
	
\end{itemize}

%------------------------------------------------------------------
\subsection{Mapeo objeto-relacional}
%-------------------------------------------------------------------
\label{cap2:subsec:mapeo-objetos}

Ya con las tablas creadas en base de datos, es necesario llevar adelante el mapeo objeto-relacional o también conocido por su definición en inglés \textit{Object-Relational mapping (ORM)}. Es una técnica de programación cuya funcionalidad es la de mapear datos entre los objetos Java y la base de datos relacional utilizada como motor de persistencia. 
\\

Esto crea una base de datos orientada a objetos virtual, sobre la base de datos relacional, posibilitando el uso de las características propias de la orientación a objetos.
\\

Para llevar adelante dicho mapeo es necesario definir las clases objetivos. Por lo tanto, al igual que fue presentado en la sección anterior el modelado de la base de datos, en la Figura \ref{fig:diagrama-modelo} se presenta el modelo equivalente en diagrama de clases de Java.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=1\textwidth]%
		{Imagenes/Bitmap/modelo_datos}
		\caption{Diagrama de clases del modelo}
		\label{fig:diagrama-modelo}
	\end{center}
\end{figure}

Tal como fue mencionado anteriormente, todas las entidades poseen un \textit{id} que hace las tareas de PK. Es por ello que se definió una clase \textit{Entity} de la que van a heredar todas las anteriores, la cual básicamente presenta un id genérico. El objetivo de la misma es abstraer el problema siguiendo las buenas prácticas de la programación orientada a objetos, indiferentemente al tipo de dato que la clase que hereda quiera manejar.
\\

A su vez, dicha entidad implementa la interfaz ``Serializable'' de Java. La serialización de un objeto consiste en convertir el mismo en una secuencia de bytes, pudiendo enviarlo a través de red, guardarlo en un fichero y después reconstruirlo al otro lado de la red.
\\

En el modelo se pueden ver las relaciones entre las distintas entidades, a través de asociaciones y composiciones según corresponda cada caso. Su análogo de representación en el modelo de base de datos eran las FK.

%------------------------------------------------------------------
\subsection{Hibernate y sus configuraciones}
%-------------------------------------------------------------------
\label{cap2:subsec:hibernate}

Para llevar adelante el mapeo objeto-relacional, se utilizó el framework \textit{Hibernate}. Es una herramienta ORM para la plataforma Java, que facilita el mapeo de atributos entre una base de datos relacional tradicional y el modelo de objetos de una aplicación, mediante archivos declarativos (XML) o anotaciones en los beans de las entidades que permiten establecer estas relaciones \cite{hibernate1}.
\\

Este framework busca solucionar el problema de la diferencia entre los dos modelos de datos coexistentes en una aplicación: el usado en la memoria de la computadora (orientación a objetos) y el usado en las bases de datos (modelo relacional). Para lograr esto permite al desarrollador detallar cómo es su modelo de datos, qué relaciones existen y qué forma tienen. Con esta información Hibernate le permite a la aplicación manipular los datos en la base de datos operando sobre objetos, con todas las características de la POO. 
\\

Hibernate convertirá los datos entre los tipos utilizados por Java y los definidos por SQL. Genera las sentencias SQL y libera al desarrollador del manejo manual de los datos que resultan de la ejecución de dichas sentencias, manteniendo la portabilidad entre todos los motores de bases de datos con un ligero incremento en el tiempo de ejecución \cite{hibernate2}.
\\

Ofrece también un lenguaje de consulta de datos llamado \textit{HQL} (Hibernate Query Language), al mismo tiempo que una API para construir las consultas programáticamente, conocida como \textit{Criteria}.
\\

En cuanto a la configuración, inicialmente se debe establecer la conexión entre la base de datos y la aplicación mediante una URL. Dicha conexión se encarga de realizarla la librería Apache Commons DBCP, mencionada anteriormente. Al tratarse del gestor MySQL corriendo de manera local, la URL a establecer es: \textit{http://localhost:3306/pfc\_encuestas}. Donde \textit{pfc\_encuestas} es el nombre de la base de datos y 3306 el puerto por defecto que ocupa MySQL. En adición, se debe definir el usuario, contraseña y el driver de conexión que depende del tipo de base de datos, en este caso \textit{com.mysql.jdbc.Driver}.
\\

Es necesario establecer el paquete Java que contiene todas las clases a mapear, mediante la propiedad \textit{packagesToScan}. Por lo tanto, dentro de la subdivisión de paquetes (de la cual se hablará en secciones posteriores), todas las clases que representan el modelo se encuentran en \textit{com.fsalmeron.encuestasfcm.model}.
\\

Todas estas configuraciones y muchas más \footnote{http://hibernate.org/} son llevadas a cabo en un archivo del tipo XML denominado \textit{servlet-context}.
\\

Para realizar el mapeo ORM, se escogió la técnica de anotaciones en lugar de archivos de mapeos XML, la cual es proporcionada por el framework y denominada ``Hibernate Annotations''. De esta forma el mapeo es mucho más práctico y se ahorran líneas de códigos, ya que en caso contrario debería anotarse una por una cada clase en el fichero XML, haciendo que la aplicación termine siendo inmanejable en su crecimiento.
\\

Inicialmente se colocan dos anotaciones a nivel clase muy importantes: en primer lugar se especifica \textbf{\textit{@Entity}}, la cual indica que la clase es una entidad, es decir un objeto Java que puede ser persistido. Seguido a ella se coloca la anotación \textbf{\textit{@Table}}, la cual especifica el nombre de la tabla en base de datos que se debe apuntar.

\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@Entity¿\aftergroup\blackcolor¿ (name = ¿\aftergroup\bluecolor¿"TIPO_USUARIO"¿\aftergroup\blackcolor¿)
	¿\aftergroup\graycolor¿@Table¿\aftergroup\blackcolor¿ (name = ¿\aftergroup\bluecolor¿"TIPO_USUARIO"¿\aftergroup\blackcolor¿)
	¿\aftergroup\purplecolor¿public class¿\aftergroup\blackcolor¿ TipoUsuario ¿\aftergroup\purplecolor¿extends ¿\aftergroup\blackcolor¿Entity<Integer>
\end{lstlisting}
~\\

A continuación, se especifican todas las anotaciones de carácter individual, es decir todas aquellas que se realizan sobre un determinado atributo o sobre la función \textit{get()} del mismo.
\\

Para indicar cuál atributo de la clase será el identificador, es decir el Primary Key, se utiliza la anotación \textbf{\textit{@Id}}. Seguido a ella, se puede personalizar la forma en que se generará el valor del identificador mediante la anotación \textbf{\textit{@GeneratedValue}}. Existen cuatro estrategias de generación: AUTO, IDENTITY, SEQUENCE y TABLE\footnote{http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/GeneratedValue.html}, donde la primer opción fue la escogida en el proyecto, ya que utiliza la estrategia por defecto de la base de datos. Además, es necesario agregar la anotación \textbf{\textit{@SequenceGenerator}} la cual define un generador de clave primaria que es referenciado por el GeneratedValue.
\\

\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@Id
	@GeneratedValue¿\aftergroup\blackcolor¿(strategy = GenerationType.¿\aftergroup\bluecolor¿AUTO¿\aftergroup\blackcolor¿, 
			generator = ¿\aftergroup\bluecolor¿"Sexo_Generator"¿\aftergroup\blackcolor¿)
	¿\aftergroup\graycolor¿@SequenceGenerator¿\aftergroup\blackcolor¿(name = ¿\aftergroup\bluecolor¿"Sexo_Generator"¿\aftergroup\blackcolor¿, 
			sequenceName = ¿\aftergroup\bluecolor¿"Sexo_Generator"¿\aftergroup\blackcolor¿)
	¿\aftergroup\purplecolor¿public¿\aftergroup\blackcolor¿ Integer getId() {
		¿\aftergroup\purplecolor¿return¿\aftergroup\blackcolor¿ id;
	}
\end{lstlisting}
~\\

Todos aquellos atributos que no estén marcados como \textbf{\textit{@Transient}}, serán persistidos. Para llevar adelante la personalización de la columna de la tabla en un determinado atributo se utiliza la anotación \textbf{\textit{@Column}}. Dentro de ella se puede especificar por ejemplo el nombre de la columna en base de datos, si es una clave única, si puede ser null, etc\footnote{http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/Column.html}.

\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@Column¿\aftergroup\blackcolor¿(name = ¿\aftergroup\bluecolor¿"DNI"¿\aftergroup\blackcolor¿, nullable = ¿\aftergroup\purplecolor¿false¿\aftergroup\blackcolor¿, unique = ¿\aftergroup\purplecolor¿true¿\aftergroup\blackcolor¿)
	¿\aftergroup\purplecolor¿public¿\aftergroup\blackcolor¿ Integer getDni() {
		¿\aftergroup\purplecolor¿return¿\aftergroup\blackcolor¿ dni;
	}
\end{lstlisting}
~\\

A la hora de mapear las relaciones que se producen entre las entidades, hay que tener en cuenta como se dá la misma para escoger la anotación adecuada. Por ejemplo, en la relación que se encuentra entre la entidad Respuesta y Pregunta, donde la primera tiene una FK sobre la segunda, el mapeo de la misma estará dado mediante la anotación \textbf{\textit{@ManyToOne}}. Dentro de ella se puede especificar entre otras cosas la estrategia para obtener datos de la base de datos, en este caso LAZY, es decir trae la información cuando la necesita. Seguido a esta anotación, se debe colocar \textbf{\textit{@JoinColumn}}, la cual permite unir dos columnas de una tabla con las FK correspondientes.

\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@ManyToOne¿\aftergroup\blackcolor¿(fetch = FetchType.¿\aftergroup\bluecolor¿LAZY¿\aftergroup\blackcolor¿)
	¿\aftergroup\graycolor¿@JoinColumn¿\aftergroup\blackcolor¿(name = ¿\aftergroup\bluecolor¿"IDPREGUNTA"¿\aftergroup\blackcolor¿)
	¿\aftergroup\purplecolor¿public¿\aftergroup\blackcolor¿ Pregunta getPregunta() {
		¿\aftergroup\purplecolor¿return¿\aftergroup\blackcolor¿ pregunta;
	}
\end{lstlisting}
~\\

En este caso se realizó un mapeo unidireccional, es decir se introdujo la anotación solamente en la entidad Respuesta. También se podría haber especificado desde el lado de Preguntas, aunque en este caso la relación sería con \textbf{\textit{@OneToMany}}. Si se presentan las anotaciones de ambos lados se dice que el mapeo es bidireccional.
\\

Por último, para la asociación entre Respuesta y Resultados, la cual presentaba una tabla extra por tratarse de una relación muchos a muchos, es mapeada bajo la anotación \textbf{\textit{@ManyToMany}}. En este caso se agregará la anotación \textbf{\textit{@JoinTable}} para esta tabla extra, y dentro de ella se encuentra el \textbf{\textit{@JoinColumn}} especificado anteriormente.

\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@ManyToMany¿\aftergroup\blackcolor¿(fetch = FetchType.¿\aftergroup\bluecolor¿LAZY¿\aftergroup\blackcolor¿)
	¿\aftergroup\graycolor¿@JoinTable¿\aftergroup\blackcolor¿(name = ¿\aftergroup\bluecolor¿"RESULTADO_RESPUESTA"¿\aftergroup\blackcolor¿), 
		joinColumns = {¿\aftergroup\graycolor¿@JoinColumn¿\aftergroup\blackcolor¿(name = ¿\aftergroup\bluecolor¿"RESULTADO"¿\aftergroup\blackcolor¿) }, 
		inverseJoinColumns = {¿\aftergroup\graycolor¿@JoinColumn¿\aftergroup\blackcolor¿(name = ¿\aftergroup\bluecolor¿"RESPUESTA"¿\aftergroup\blackcolor¿)})
	¿\aftergroup\purplecolor¿public¿\aftergroup\blackcolor¿ List<Respuesta> getRespuestas(){
		¿\aftergroup\purplecolor¿return¿\aftergroup\blackcolor¿ respuestas;
	}
\end{lstlisting}
~\\
%------------------------------------------------------------------
\subsection{Arquitectura}
%-------------------------------------------------------------------
\label{cap2:subsec:arquitectura}

La arquitectura de sistema escogida para el desarrollo del Web Service, fue la de programación por capas. El principal objetivo de este modelo de desarrollo de software es la separación de las partes que componen una arquitectura del tipo cliente-servidor. 
\\

Con esta arquitectura el software se divide en tres niveles diferentes: capa de presentación, capa de negocio o servicios y capa de datos o persistencia (Figura \ref{fig:modelo_capas}). La principal ventaja que presenta este modelo, es que permite desarrollar y mantener en forma desacoplada cada nivel, sin afectar a las demás.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.8\textwidth]%
		{Imagenes/Bitmap/arquitectura_ws}
		\caption{Arquitectura modelo de capas}
		\label{fig:modelo_capas}
	\end{center}
\end{figure}

\begin{itemize}
	
	\item \textbf{\textit{Capa de presentación:}} Es el nivel superior de la aplicación, básicamente con la que interactúa el usuario, por ello es también llamada ``capa de usuario''. Recibe la información por parte de la capa de negocio. Comúnmente al estar relacionada directamente con el usuario, se utilizan distintas tecnologías para presentar una interfaz de uso intuitivo sin mayores complejidades. Sin embargo, el objetivo de este proyecto es retornar la respuesta en formato JSON, donde el usuario final será la aplicación móvil. La capa de presentación en el Web Service estará implementada mediante Controladores, lo cuales serán detallados en secciones posteriores.
	
	\item \textbf{\textit{Capa de negocio:}} Es la capa intermedia que contiene toda la lógica de negocio necesaria. Se encuentra comunicada con la capa de presentación y la capa de persistencia. Trata todas las peticiones que el usuario ha realizado mediante la capa de presentación, aplica las reglas de negocio y se encarga de enviarle una respuesta de vuelta. A la hora de aplicar la lógica, es pertinente recuperar datos o persistirlos en la base de datos mediante la comunicación con la capa de persistencia.
	
	\item \textbf{\textit{Capa de persistencia:}} Es también denominada como ``capa de datos''. Es la última capa encargada de proporcionar una biblioteca de funcionalidades para el acceso a la base de datos, lugar en el que reside la información. Está formada por el gestor de base de datos, que permite el acceso a los mismos para su consulta, actualización, almacenamiento o eliminación. Se comunica con la capa de negocios facilitando datos o recibiéndolos.
	
\end{itemize}

%------------------------------------------------------------------
\subsection{Spring y diseño de las capas}
%-------------------------------------------------------------------
\label{cap2:subsec:spring}

Para llevar adelante la división de capas de la arquitectura propuesta, se utilizó \textit{Spring Framework}. Es una herramienta de gran utilidad para el desarrollo de aplicaciones web, permitiendo entre otras cosas la \textit{inversión de control (IoC)}, es decir el flujo principal de ejecución está determinado por las respuestas que se deben dar ante un determinado suceso, a diferencia de la ejecución concurrente en la programación tradicional \cite{spring2}.
\\

La inversión de control es un patrón de diseño de software en el que el flujo de ejecución de un programa y vida de los objetos se invierte respecto a los métodos de programación tradicionales. Es el framework el que toma el control, encargándose de administrar los componentes (crearlos en orden correcto, conectarlos entre sí, configurarlos), es decir definir el flujo de actuación o el ciclo de vida de una petición.
\\

En los métodos de programación tradicionales la interacción se expresa de forma imperativa haciendo llamadas a procedimientos o funciones. Tradicionalmente el programador especifica la secuencia de decisiones y procedimientos que pueden darse durante el ciclo de vida de un programa mediante llamadas a funciones. En su lugar, en la inversión de control se especifican respuestas deseadas a sucesos o solicitudes de datos concretas, dejando que una entidad intermedia entre el controlador frontal y la lógica del problema lleve a cabo las acciones de control que se requieran en el orden necesario y para el conjunto de sucesos que tengan que ocurrir (Figura \ref{fig:ioc}) \cite{spring1}.
\\

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.76\textwidth]%
		{Imagenes/Bitmap/ioc}
		\caption{Inversión de control}
		\label{fig:ioc}
	\end{center}
\end{figure}

Esto favorece la modularización del código, al evitar la dependencia directa entre unos componentes y otros pero también favorece la reutilización del mismo, ya que permite la creación de módulos independientes del resto de la aplicación.
\\

Además, Spring provee la \textit{inyección de dependencias (DI)}, que es un tipo de inversión de control. Es un patrón de diseño orientado a objetos, donde en lugar de que cada clase tenga que instanciar los objetos que necesite, Spring se encarga de inyectar los mismos mediante los setters o el constructor en el momento que se cree la clase (en tiempo de ejecución) y cuando se quiera utilizar la misma ya estará lista. Para ello, dentro de Spring hay un contenedor que se encarga de inyectar a cada objeto, los objetos que necesita según se le indique, mediante un archivo de configuración XML o anotaciones sobre los beans (\textit{@Autowired}). La inyección de dependencias en este proyecto está basada en Interfaces de Java.
\\

Siguiendo con el modelo de capas establecido, se puede mencionar que Spring posee un módulo denominado \textit{WebMVC}, basado en el patrón modelo vista-controlador. Para ello presenta una serie de anotaciones que permiten diferenciar los elementos por cada capa: controladores, servicios y DAO (Data Access Object).
\\

\begin{figure}[h!]
	\makebox[\textwidth][c]{\includegraphics[width=1.6\textwidth, height=1.3\textwidth]{Imagenes/Bitmap/diagrama_ws}}%
	\caption{Diagrama de clases del Web Service}
	\label{fig:diagramaws}
\end{figure}

En la Figura \ref{fig:diagramaws}\footnote{Para visualizar con mayor presición ingresar a: https://ibb.co/8xsw1Ch} se puede ver claramente la mencionada separación por capas, de acuerdo a la arquitectura establecida. Siguiendo un flujo de secuencia normal, el usuario ejecuta una consulta desde la aplicación móvil, la cual se encarga de enviar una petición HTTP (\textit{request}) al Web Service. La misma llega al controlador frontal o mejor conocido como \textit{Dispatcher Servlet} que se encarga de enrutarla hacia el controlador indicado, que se encuentra dentro de la capa de presentación. A su vez, el Dispatcher es el encargado de encapsular y abstraer muchas funcionalidades estandarizadas en Spring, mediante la declaración de beans específicos o el uso de anotaciones.
\\

Las clases que se encuentran en dicha capa presentan la anotación de carácter general \textbf{\textit{@Controller}}. Corresponde al framework de Spring y sirve para identificar a las clases como tal, ya que son detectadas automáticamente a través del escaneo classpath. Además, se encuentra la anotación \textbf{\textit{@RequestMapping}} que se encarga de definir el path o dirección del recurso.
\\
\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@Controller
	@RequestMapping¿\aftergroup\blackcolor¿(value = ¿\aftergroup\bluecolor¿"/usuarios"¿\aftergroup\blackcolor¿)
	¿\aftergroup\purplecolor¿public class ¿\aftergroup\blackcolor¿UserController
\end{lstlisting}
~\\

Teniendo en cuenta que el nombre del proyecto es \textit{EncuestasFCM}, la URL a nivel local para acceder al controlador de usuarios por ejemplo es:
\begin{center}
	\textit{http://localhost:8080/EncuestasFCM/usuarios}
\end{center}
~\\

Dentro de cada controlador se van a encontrar distintos endpoints (métodos) funcionando bajo su contexto. Cada uno de ellos, posee a su vez la anotación \textbf{\textit{@RequestMapping}}, la cual indica la dirección del recurso y el método de la request, entre otras cosas. Es decir, dentro de un controlador se pueden hallar métodos que tengan el mismo path, pero distinto tipo de request (por ejemplo uno GET y otro POST). También cuentan con la anotación \textbf{\textit{@ResponseBody}}, que indica que el tipo de devolución debe escribirse directamente en el cuerpo de respuesta HTTP.
\\
\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@RequestMapping¿\aftergroup\blackcolor¿(value = ¿\aftergroup\bluecolor¿"/getAll"¿\aftergroup\blackcolor¿, 
		method = RequestMethod.¿\aftergroup\bluecolor¿GET¿\aftergroup\blackcolor¿, 
		produces = ¿\aftergroup\bluecolor¿"text/plain;charset=UTF-8"¿\aftergroup\blackcolor¿)
	¿\aftergroup\graycolor¿@ResponseBody
	¿\aftergroup\purplecolor¿public ¿\aftergroup\blackcolor¿String getEncuestas()
\end{lstlisting}
~\\

Para este método en específico, cuyo path es \textit{/getAll} y una request del tipo GET, la URL es la siguiente:

\begin{center}
	\textit{http://localhost:8080/EncuestasFCM/encuestas/getAll}
\end{center}
~\\

Existen situaciones en las que se envían parámetros en la petición HTTP, como por ejemplo el id de una encuesta a eliminar. Para ello se utiliza la anotación \textbf{\textit{@RequestParam}} junto a su nombre.
\\
\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@RequestMapping¿\aftergroup\blackcolor¿(value = ¿\aftergroup\bluecolor¿"/removeEncuesta"¿\aftergroup\blackcolor¿, 
		method = RequestMethod.¿\aftergroup\bluecolor¿PUT¿\aftergroup\blackcolor¿, 
		produces = ¿\aftergroup\bluecolor¿"text/plain;charset=UTF-8"¿\aftergroup\blackcolor¿)
	¿\aftergroup\graycolor¿@ResponseBody
	¿\aftergroup\purplecolor¿public ¿\aftergroup\blackcolor¿String removeEncuesta(¿\aftergroup\graycolor¿@RequestParam¿\aftergroup\blackcolor¿(¿\aftergroup\bluecolor¿"idEncuesta"¿\aftergroup\blackcolor¿) 
		Integer idEncuesta, ¿\aftergroup\graycolor¿@RequestParam¿\aftergroup\blackcolor¿(¿\aftergroup\bluecolor¿"idUsuario"¿\aftergroup\blackcolor¿) 
		Integer idUsuario)
\end{lstlisting}
~\\

En este ejemplo puntual, se puede ver que el tipo de request es PUT y no DELETE, ya que como se mencionó anteriormente el borrado será lógico, es decir la base de datos se actualizará colocando a la encuesta como activa en falso y completando los campos de fecha de baja y usuario de baja para el control de auditorias. En estos casos, la URL de acceso estará formada por dichos parámetros. El primero de ellos es separado por el carácter ?, mientras que los siguientes serán por \&:
\begin{center}
	\textit{http://localhost:8080/EncuestasFCM/encuestas/removeEncuesta?idEncuesta=1}
	\&\textit{idUsuario=1}
\end{center}
~\\

Para el caso de aquellos endpoints en los que se debe transportar gran cantidad de información, por lo cual enviar los mismos en parámetros no respetaría las buenas prácticas de la programación, ya que cargaría con mucha información la URL por ejemplo, se obtienen mediante un objeto denominado \textbf{\textit{HttpServletRequest}}. Proporciona acceso a los datos de cabecera HTTP, como cualquier cookie encontrada en la petición, y el método HTTP con el que se ha realizado la petición. Además, permite obtener los argumentos que el cliente envía como parte de la petición. De esta forma los datos son enviados desde el cliente con un formato JSON y mediante la utilización de la biblioteca GSON mencionada anteriormente, se serializa el objeto correspondiente.
\\
\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@RequestMapping¿\aftergroup\blackcolor¿(value = ¿\aftergroup\bluecolor¿"/saveUser"¿\aftergroup\blackcolor¿, 
		method = RequestMethod.¿\aftergroup\bluecolor¿POST¿\aftergroup\blackcolor¿, 
		produces = ¿\aftergroup\bluecolor¿"text/plain;charset=UTF-8"¿\aftergroup\blackcolor¿)
	¿\aftergroup\graycolor¿@ResponseBody
	¿\aftergroup\purplecolor¿public ¿\aftergroup\blackcolor¿String saveUser(HttpServletRequest http)
\end{lstlisting}
~\\

Teniendo en cuenta que se trata de una nueva persistencia en la base de datos, se trata de una request del tipo POST. Con toda la información enviada como argumentos la URL queda de la siguiente forma:

\begin{center}
	\textit{http://localhost:8080/EncuestasFCM/usuarios/saveUser}
\end{center}
~\\

La capa de presentación se encuentra comunicada con la de servicios, que es la encargada de aplicar toda la lógica de negocios correspondiente. Como se pudo ver en el diagrama de clases de la Figura \ref{fig:diagramaws}, por cada entidad creada se asocia un servicio, los cuales se encuentran anotados a nivel clase bajo \textbf{\textit{@Service}}. Dicha anotación de Spring indica que la clase es un bean de la capa de negocios. Además, se presenta la anotación \textbf{\textit{@Scope}} que indica el ámbito de los objetos creados. En nuestro caso siempre se tratará de \textbf{\textit{Scopes Singleton}}, esto significa que el contenedor solo instancia un objeto de la clase, y cada vez que se pide una instancia del bean en realidad se obtiene una referencia al mismo objeto, evitando tener múltiples objetos que accedan a la base de datos, implicando mayor cantidad de conexiones por ejemplo.
\\
\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@Service
	@Scope¿\aftergroup\blackcolor¿(ConfigurableBeanFactory.¿\aftergroup\bluecolor¿SCOPE_SINGLETON¿\aftergroup\blackcolor¿)
	¿\aftergroup\purplecolor¿public class ¿\aftergroup\blackcolor¿PreguntaServiceImpl 
		¿\aftergroup\purplecolor¿extends¿\aftergroup\blackcolor¿BaseServiceImpl<Pregunta, Integer> 
		¿\aftergroup\purplecolor¿implements ¿\aftergroup\blackcolor¿PreguntaService
\end{lstlisting}
~\\

Todas las clases de servicio implementan una interfaz, por la inyección de dependencias propiamente dicha del framework. A su vez, tanto las clases como las interfaces extienden de otras genéricas denominadas base. Estas son \textbf{\textit{BaseServiceImpl}} y \textbf{\textit{BaseService}}, respectivamente. Esto permite abstraer y reutilizar código, ya que todos los servicios presentan funcionalidades similares: obtener un objeto por el id, traer todos los objetos de una clase, filtrarlos, guardarlos o modificarlos, eliminarlos, etc.
\\

Por último, la capa de servicios se encuentra comunicada con la de acceso a datos. Esta es la capa de más bajo nivel, la cual posee acceso a la base de datos, por eso las entidades dentro de ella son denominados DAO (Objetos de acceso a datos). Al igual que las distintas capas, posee una anotación a nivel clase denominada \textbf{\textit{@Repository}}. La misma determina que se trata de una clase relacionada con la capa de persistencia y definida como Singleton.
\\
\begin{lstlisting}[escapechar=¿]
	¿\aftergroup\graycolor¿@Repository
	¿\aftergroup\purplecolor¿public class ¿\aftergroup\blackcolor¿RespuestaDaoImpl 
		¿\aftergroup\purplecolor¿extends ¿\aftergroup\blackcolor¿BaseDaoImpl<Respuesta, Integer> 
		¿\aftergroup\purplecolor¿implements¿\aftergroup\blackcolor¿ RespuestaDao{
\end{lstlisting}
~\\

De la misma forma que en los servicios, se definió genéricamente una clase y una interfaz base denominados \textbf{\textit{BaseDaoImpl}} y \textbf{\textit{BaseDao}}, respectivamente. Dicho DAO es inyectado dentro de la clase BaseServiceImpl para llevar adelante la comunicación entre las capas. Dentro de la clase se encuentra un objeto \textbf{\textit{SessionFactory}}, propio del framework Hibernate e inyectado por Spring, que se encarga de ir a la base de datos y ejecutar las consultas. Las mismas pueden ser ejecutadas mediante HQL (lenguaje SQL propio de Hibernate) o Criteria (API de consultas de Hibernate, mediante la manipulación de objetos).
\\

Finalmente, el DAO realiza la transacción y retorna un mensaje al servicio nuevamente, este aplica las reglas de negocios que hagan falta y envía el mensaje al controlador. Este último transforma la respuesta en formato JSON y lo entrega al Dispatcher que se encarga de enviar una respuesta HTTP (\textit{response}) al cliente.

%------------------------------------------------------------------
\subsection{Puesta en funcionamiento del Web Service}
%-------------------------------------------------------------------
\label{cap2:subsec:instalacionws}

Tal como se había especificado en secciones anteriores, el Web Service es un Servlet particular funcionando dentro del contenedor de Servlets Apache Tomcat. Este se encarga de direccionar las peticiones que le llegan a través del puerto 8080.
\\

Existe gran cantidad de contenedores disponibles para su elección, como por ejemplo Glassfish, JBoss, Wildfly, JOnAS, entre otros. Dentro de las razones que llevaron a escoger Tomcat se puede mencionar que es sumamente ligero, open source, flexible, presenta mayor estabilidad por su instalación independiente de Apache, y ofrece un nivel extra de seguridad \cite{tomcat}.
\\

Mediante la utilización del entorno local de prueba, se llevó adelante la instalación de la aplicación en el contenedor bajo el IDE Eclipse. Este soporta la inclusión de múltiples contenedores de Servlets. Para el caso de entornos productivos, la instalación puede llevarse a cabo mediante Tomcat Monitor, una herramienta especial de Tomcat para estas situaciones.

%------------------------------------------------------------------
\subsection{Estructura del proyecto}
%-------------------------------------------------------------------
\label{cap2:subsec:estructuraWs}

Anteriormente se presentó la estructura básica de un proyecto Maven. En esta sección, con la finalidad de mantener separadas todas las clases de acuerdo a sus utilidades y siguiendo las buenas prácticas de programación, se crearon distintos paquetes en el proyecto, como se puede ver en la Figura \ref{fig:paquetes_ws}.
\\

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.6\textwidth]%
		{Imagenes/Bitmap/paquetes_ws}
		\caption{División de funcionalidades por paquetes}
		\label{fig:paquetes_ws}
	\end{center}
\end{figure}

De acuerdo al diagrama de Web Service presentado en secciones previas, las distintas capas de la arquitectura fueron separadas en relación al patrón MVC mencionado. Es decir, el paquete \textit{controller} está asociado a la capa de presentación, el \textit{dao} (interfaces) y sus implementaciones a la capa de datos, y por último el \textit{service} (interfaces) junto a sus implementaciones, \textit{filter} y \textit{utils} con la capa de servicios.
\\

Dentro del paquete base se encuentran todas aquellas interfaces y clases genéricas que serán extendidas según correspondan (Figura \ref{fig:paquete_base}). Cabe destacar que la clase Persistence representa una entidad del dominio que puede ser persistida, la cual es extendida por las demás ``bases''. Como ya se mencionó, dentro del BaseDao se encuentran funciones genéricas como filtros, traer objetos por id, guardar o eliminar objetos en base de datos, etc.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.6\textwidth]%
		{Imagenes/Bitmap/paquete_base}
		\caption{Paquete base}
		\label{fig:paquete_base}
	\end{center}
\end{figure}

Por su parte, en el paquete \textit{model} se encuentran todas las clases Java que representan el mapeo de objetos en relación a la base de datos, con sus respectivas anotaciones Hibernate. Las mismas extienden de la clase base \textit{Entity}.
\\

Cabe aclarar que dentro del paquete \textit{utils}, se desarrolló una clase denominada \textit{EncryptionUtils}. La misma contiene dos funciones para llevar a cabo la codificación y decodificación de un determinado String bajo el sistema \textit{Base64}. Este sistema numérico, utiliza 64 como base que es la mayor potencia de dos que puede ser representada usando únicamente los caracteres imprimibles de ASCII, a la hora de encriptar códigos. 
\\

Por ejemplo, a la hora de crear un nuevo usuario, cuando se pasa la contraseña a almacenar por el parámetro de la petición, se procede a encriptar la misma como un mecanismo de seguridad a nivel base de datos (quedando almacenado un alfanumérico, por ejemplo \textit{bZOnEJcdujc}). A su vez, utilizando el método de decodificación se puede obtener el texto original.

%------------------------------------------------------------------
\subsection{Servicios}
%-------------------------------------------------------------------
\label{cap2:subsec:serviciosWs}

En la presente sección se describirán todos los servicios pertenecientes al Web Service, su direccionamiento y tipo de respuesta.
\\

Inicialmente se presentan los endpoints disponibles en el controlador de usuarios:

\begin{itemize}
	
	\item \textbf{\textit{Alta de un usuario}}:
	
	\textit{http://localhost:8080/EncuestasFCM/usuarios/saveUser}
	
	Es una request del tipo POST y como se mencionó anteriormente, todos los datos correspondientes al Usuario son enviados como argumentos en formato JSON dentro del objeto HttpServletRequest. El servicio relacionado al controlador valida que todos los datos sean correctos y devuelve una respuesta. Dentro de las validaciones que realiza, comprueba que el nombre de usuario, mail y DNI no estén en uso, que no haya caracteres especiales, longitud de los campos, etc. Como respuesta envía un JSON indicando el éxito o no de la transacción y el error en caso de tenerlo. 
	
	A continuación se presenta un ejemplo de respuesta cuando no se cumplen las validaciones y un ejemplo de creación exitosa:
	\\
	
	\begin{lstlisting}[escapechar=¿]
	{
		¿\aftergroup\bluecolor¿"exito"¿\aftergroup\blackcolor¿:false,
		¿\aftergroup\bluecolor¿"error"¿\aftergroup\blackcolor¿:"El nombre de usuario escogido ya se 
			encuentra en uso."
	}
	\end{lstlisting}
	
	\begin{lstlisting}[escapechar=¿]
	{
		¿\aftergroup\bluecolor¿"exito"¿\aftergroup\blackcolor¿:true
	}
	\end{lstlisting}

	\item \textbf{\textit{Login de un usuario}}:
	
	\textit{http://localhost:8080/EncuestasFCM/usuarios/loginUser}?\textit{nombre=...}\&
	\textit{password=...}
	
	Request del tipo GET, que recibe como parámetros el nombre de usuario y la password encriptada. Se descifra la misma y se verifica que los datos sean correctos, es decir usuario existente y contraseña correcta, retornando un JSON con el éxito de la transacción y los datos del usuario o el error sucedido en caso contrario.
	
	Al igual que en el caso anterior, se presenta un ejemplo de respuesta con un logueo incorrecto y otro correcto:
	\\
	
	\begin{lstlisting}[escapechar=¿]
	{
		¿\aftergroup\bluecolor¿"exito"¿\aftergroup\blackcolor¿:false,
		¿\aftergroup\bluecolor¿"error"¿\aftergroup\blackcolor¿:"La contraseña ingresada es incorrecta"
	}
	\end{lstlisting}
	
	\begin{lstlisting}[escapechar=¿]
	{
		¿\aftergroup\bluecolor¿"exito"¿\aftergroup\blackcolor¿:true,
		¿\aftergroup\bluecolor¿"tipoUsuario"¿\aftergroup\blackcolor¿:...,
		¿\aftergroup\bluecolor¿"id"¿\aftergroup\blackcolor¿:...,
		¿\aftergroup\bluecolor¿"sexo"¿\aftergroup\blackcolor¿:...,
		¿\aftergroup\bluecolor¿"nombreUsuario"¿\aftergroup\blackcolor¿:"...",
		¿\aftergroup\bluecolor¿"edad"¿\aftergroup\blackcolor¿: ...,
		¿\aftergroup\bluecolor¿"nombre"¿\aftergroup\blackcolor¿: "...",
		¿\aftergroup\bluecolor¿"apellido"¿\aftergroup\blackcolor¿: "..."
	}
	\end{lstlisting}
\end{itemize}

La mayor cantidad de servicios se presentan en el controlador de encuestas, ya que se trata del núcleo del proyecto:

\begin{itemize}
	
	\item \textbf{\textit{Traer todas las encuestas}}: 
	
	\textit{http://localhost:8080/EncuestasFCM/encuestas/getAll}
	
	Se trata de una request del tipo GET que retorna un JSON con un arreglo de todas las encuestas que se encuentran activas en base de datos (estén habilitadas o no). Trae sólo los datos suficientes para ser presentadas dentro de la sección ``Administración de encuestas'' en la aplicación móvil (como se verá más adelante).
	\\
	
	\begin{lstlisting}[escapechar=¿]
	{
		¿\aftergroup\bluecolor¿"response"¿\aftergroup\blackcolor¿:[
			{
				¿\aftergroup\bluecolor¿"descripcion"¿\aftergroup\blackcolor¿:"...",
				¿\aftergroup\bluecolor¿"titulo"¿\aftergroup\blackcolor¿:"...",
				¿\aftergroup\bluecolor¿"id"¿\aftergroup\blackcolor¿:...,
				¿\aftergroup\bluecolor¿"usuario"¿\aftergroup\blackcolor¿: "...",
				¿\aftergroup\bluecolor¿"fecha"¿\aftergroup\blackcolor¿: ...,
				¿\aftergroup\bluecolor¿"geolocalizada"¿\aftergroup\blackcolor¿: ...,
				¿\aftergroup\bluecolor¿"resoluciones"¿\aftergroup\blackcolor¿: ...,
				¿\aftergroup\bluecolor¿"isSexoRestriccion"¿\aftergroup\blackcolor¿: ...,
				¿\aftergroup\bluecolor¿"isEdadRestriccion"¿\aftergroup\blackcolor¿: ...,
				¿\aftergroup\bluecolor¿"habilitada"¿\aftergroup\blackcolor¿: ...
				
			},
			{
				...
			}
		]
	}
	\end{lstlisting}
	
	\item \textbf{\textit{Traer solamente encuestas habilitadas}}: 
	
	\textit{http://localhost:8080/EncuestasFCM/encuestas/getAllHabilitadas}
	
	Se trata de una request del tipo GET que retorna un JSON con un arreglo de todas las encuestas que se encuentran activas y habilitadas en base de datos. Que se encuentren habilitadas significa que ya están disponibles para ser resueltas. Al igual que el endpoint anterior, trae los mismos datos de respuesta suficientes para ser presentadas dentro de la sección ``Encuestas Disponibles''.
	
	
	\item \textbf{\textit{Alta de una encuesta}}: 
	
	\textit{http://localhost:8080/EncuestasFCM/encuestas/saveEncuesta}
	
	Request del tipo POST, en el cual se manda un JSON con todos los datos de la encuesta, preguntas y respuestas dentro del objeto HttpServletRequest. La misma será dada de alta, quedando como activa e inhabilitada (no disponible para resolución, pero sí para ser modificada). En este caso no requiere validaciones por parte del servicio, ya que las mismas serán realizadas desde la misma aplicación.
	
	Como respuesta se envía un booleano indicando el éxito de la transacción y el id asignado a la encuesta:
	
	\begin{lstlisting}[escapechar=¿]
	{
		¿\aftergroup\bluecolor¿"exito"¿\aftergroup\blackcolor¿:true,
		¿\aftergroup\bluecolor¿"idAsignado"¿\aftergroup\blackcolor¿:...
	}
	\end{lstlisting}
	
	\item \textbf{\textit{Modificación de una encuesta}}: 
	
	\textit{http://localhost:8080/EncuestasFCM/encuestas/updateEncuesta}
	
	Se trata de una request del tipo PUT, en donde se envían todos los datos de la encuesta, junto a las preguntas y respuestas en formato JSON dentro del objeto HttpServletRequest. En este caso se llevará adelante una verificación sobre las preguntas y respuestas para tener en cuenta cuales fueron modificadas, eliminadas o agregadas, realizando las acciones pertinentes. Este endpoint será accedido solamente cuando la encuesta se encuentre en estado activa e inhabilitada, aunque dicha validación será llevada a cabo en la aplicación como se verá posteriormente. 
	
	Como respuesta se envía un booleano indicando el éxito de la transacción.
	
	\item \textbf{\textit{Eliminación de una encuesta}}: 
	
	\textit{http://localhost:8080/EncuestasFCM/encuestas/removeEncuesta}
	?\textit{idEncuesta=...}\& \textit{idUsuario=...}
	
	Se trata de una request del tipo PUT, ya que como se mencionó anteriormente la baja será lógica y no se tratará de un DELETE físico de los datos. Recibe como parámetros el id de la encuesta a eliminar y el id del usuario encargado de la transacción. Internamente el servicio se encarga de completar los datos de auditoría como fecha y usuario de baja, y la setea como inactiva e inhabilitada. El JSON de retorno indicará el éxito de la transacción.
	
	\item \textbf{\textit{Habilitación de una encuesta}}: 
	
	\textit{http://localhost:8080/EncuestasFCM/encuestas/enableEncuesta}
	?\textit{idEncuesta=...}\& \textit{idUsuario=...}
	
	Request del tipo PUT que recibe como parámetros el id de la encuesta y del usuario encargado. En este caso coloca a la encuesta como habilitada, haciendo que la misma quede disponible para su resolución.
	
	\item \textbf{\textit{Inhabilitación de una encuesta}}: 
	
	\textit{http://localhost:8080/EncuestasFCM/encuestas/disableEncuesta}
	?\textit{idEncuesta=...}\& \textit{idUsuario=...}
	
	Request del tipo PUT que recibe como parámetros el id de la encuesta y del usuario encargado. En este caso coloca a la encuesta como inhabilitada, haciendo que la misma no se encuentre disponible para su resolución.
	
	\item \textbf{\textit{Abrir una encuesta}}: 
	
	\textit{http://localhost:8080/EncuestasFCM/encuestas/openEncuesta}
	?\textit{idEncuesta=...}
	
	Se trata de una request del tipo GET que recibe como parámetro el id de la encuesta a abrir. Como ya se especificó en servicios anteriores, las encuestas se presentan en la sección que correspondan con la cantidad mínima de datos. Cuando una de ellas es accedida para ser modificada o resuelta, se invoca el presente servicio que se encarga de traer todos los datos de la misma.
	
	Como respuesta se obtendrá un JSON con todos los datos de la encuesta, preguntas y respuestas:
	
	\begin{lstlisting}[escapechar=¿]
	{
		¿\aftergroup\bluecolor¿"id"¿\aftergroup\blackcolor¿:...,
		¿\aftergroup\bluecolor¿"descripcion"¿\aftergroup\blackcolor¿:...,
		¿\aftergroup\bluecolor¿"titulo"¿\aftergroup\blackcolor¿:...,
		¿\aftergroup\bluecolor¿"preguntas"¿\aftergroup\blackcolor¿:[
			{
				¿\aftergroup\bluecolor¿"idPregunta"¿\aftergroup\blackcolor¿:...,
				¿\aftergroup\bluecolor¿"descripcionPregunta"¿\aftergroup\blackcolor¿:...,
				¿\aftergroup\bluecolor¿"tipoPregunta"¿\aftergroup\blackcolor¿:...,
				¿\aftergroup\bluecolor¿"respuestas"¿\aftergroup\blackcolor¿:[
					{
						¿\aftergroup\bluecolor¿"idRespuesta"¿\aftergroup\blackcolor¿:...,
						¿\aftergroup\bluecolor¿"descripcion"¿\aftergroup\blackcolor¿:...
					},
					{
						...
					}
				]
			},
			{
				...
			}
		]
	}
	\end{lstlisting}
	
\end{itemize}

A la hora de resolver las encuestas y obtener las estadísticas de las mismas se utilizan los servicios disponibles en el controlador de Resultado:

\begin{itemize}
	
	\item \textbf{\textit{Resolver una encuesta}}:
	
	\textit{http://localhost:8080/EncuestasFCM/resultados/saveResultado}
	
	Se trata de una request del tipo POST, la cual recibe como argumento un JSON con los resultados de resolución de una encuesta dentro del objeto HttpServletRequest. Las validaciones de las respuestas serán realizadas dentro de la aplicación móvil. Retorna como respuesta un JSON informando el éxito de la transacción.
	
	\item \textbf{\textit{Obtener resultados de una encuesta}}:
	
	\textit{http://localhost:8080/EncuestasFCM/resultados/getResultado}
	?\textit{idEncuesta=...}
	
	Se trata de una request del tipo GET que recibe como parámetro el id de la encuesta a analizar. Se envían todas las resoluciones pertinentes a dicha encuesta, para que de esta forma la aplicación móvil realice todas las estadísticas necesarias para presentar en pantalla.
	
	Como respuesta se envía un JSON que posee un arreglo de resoluciones, como se puede ver a continuación:
	
	\begin{lstlisting}[escapechar=¿]
	{
		¿\aftergroup\bluecolor¿"response"¿\aftergroup\blackcolor¿:[
			{
				¿\aftergroup\bluecolor¿"latitud"¿\aftergroup\blackcolor¿:...,
				¿\aftergroup\bluecolor¿"longitud"¿\aftergroup\blackcolor¿:...,
				¿\aftergroup\bluecolor¿"idRespuesta"¿\aftergroup\blackcolor¿:...,
				¿\aftergroup\bluecolor¿"descripcion"¿\aftergroup\blackcolor¿:...,
				¿\aftergroup\bluecolor¿"sexo"¿\aftergroup\blackcolor¿:...,
				¿\aftergroup\bluecolor¿"edad"¿\aftergroup\blackcolor¿:...
			},
			{
				...
			}
		]
	}
	\end{lstlisting}
	
\end{itemize}

Finalmente, se presentan todos los servicios correspondientes al controlador de Información y Noticias:

\begin{itemize}
	
	\item \textbf{\textit{Crear información o noticia}}:
	
	\textit{http://localhost:8080/EncuestasFCM/infoNoticias/saveInfo}
	
	Request del tipo POST, que recibe como argumento un JSON con los datos de la información a dar de alta dentro del objeto HttpServletRequest. Las validaciones de los mismos serán llevadas a cabo dentro de la aplicación. Retorna como respuesta un JSON informando el éxito de la transacción.
	
	\item \textbf{\textit{Traer todas las informaciones}}:
	
	\textit{http://localhost:8080/EncuestasFCM/infoNoticias/getAll}
	
	Request del tipo GET que tiene por finalidad retornar un JSON con un arreglo de todas las informaciones y noticias disponibles en base de datos.
	
	\begin{lstlisting}[escapechar=¿]
	{
		¿\aftergroup\bluecolor¿"response"¿\aftergroup\blackcolor¿:[
			{
				¿\aftergroup\bluecolor¿"id"¿\aftergroup\blackcolor¿:...,
				¿\aftergroup\bluecolor¿"titulo"¿\aftergroup\blackcolor¿:...,
				¿\aftergroup\bluecolor¿"descripcion"¿\aftergroup\blackcolor¿:...,
				¿\aftergroup\bluecolor¿"url"¿\aftergroup\blackcolor¿:...
			},
			{
				...
			}
		]
	}
	\end{lstlisting}
	
	\item \textbf{\textit{Eliminar una información}}:
	
	\textit{http://localhost:8080/EncuestasFCM/infoNoticias/removeInfo}
	?\textit{idInfo=...}
	
	Se trata de una request del tipo DELETE, que recibe como parámetro el id de la info. En este caso la baja será del tipo física, ya que no se trata de información sensible como pueden ser las encuestas, las cuáles son el núcleo del proyecto. Como respuesta se envía un JSON informando el éxito de la transacción.
	
	
\end{itemize}

\newpage
\thispagestyle{empty}
\mbox{ }